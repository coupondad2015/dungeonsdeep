<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dungeons Deep ‚Äî ASCII Roguelike</title>
  <style>
  .skip-btn{
    margin-left: 12px;
    width: 40px;
    height: 32px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.04);
    color: rgba(230,240,255,.95);
    cursor: pointer;
    line-height: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .skip-btn:hover{
    background: rgba(255,255,255,.06);
    border-color: rgba(255,255,255,.24);
  }


    #restartBtn.btn-lose{
      border-color: rgba(220,50,50,.9);
      color: #ffd0d0;
      box-shadow: 0 0 0 1px rgba(220,50,50,.25), 0 0 18px rgba(220,50,50,.18);
    }
    #restartBtn.btn-win{
      border-color: rgba(70,220,120,.9);
      color: #d8ffe4;
      box-shadow: 0 0 0 1px rgba(70,220,120,.22), 0 0 18px rgba(70,220,120,.14);
    }
.hud-debug{
    margin-top: 6px;
    padding: 4px 8px;
    font-size: 11px;
    opacity: 0.75;
    border: 1px dashed rgba(255,255,255,.20);
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    border-radius: 10px;
  }
:root { color-scheme: dark; }
    body{
      margin:0;
      background:#0b0f12;
      color:#cfd8dc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      display:flex;
      justify-content:center;
    }
    .wrap{ width:min(1100px, 98vw); padding:12px; }

    .panel{
      background:#0f151a;
      border:1px solid #1b2a33;
      border-radius:12px;
      padding:10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    /* === Compact full-width header band === */
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .header{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:8px 10px; /* tighter */
    }
    .header-left{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      flex: 1 1 auto;
      min-width: 0;
    }
    .header-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex:0 0 auto;
    }

    /* HUD becomes a compact wide row of pills */
    .hud{
      display:flex;
      flex-wrap:wrap;
      gap:6px 10px;
      align-items:center;
      min-width:0;
      font-size:12px;
      line-height:1.1;
    }
    .hud .hud-item{
      display:inline-flex;
      align-items:baseline;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #2a3b45;
      background:#0b1115;
      white-space:nowrap;
    }
    .hud .title{
      font-weight:800;
      letter-spacing:.5px;
      border-color:#355262;
    }
    .hud .muted{ opacity:.88; }
    
    /* Logo replaces the title pill */
    .hud-item.title.hud-logo{
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0 !important;
    }

    .hud-logo img{
        height: 38px;      /* tweak to taste */
        width: auto;
        display: block;
    }

    .controls{
      font-size:12px;
      opacity:.92;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 520px;
    }

    kbd{
      border:1px solid #2a3b45; border-bottom-width:2px;
      padding:0 6px; border-radius:6px; background:#0b1115;
      font-size:12px;
      display:inline-block;
      margin:0 1px;
    }
    button{
      background:#0b1115; color:#cfd8dc;
      border:1px solid #2a3b45;
      border-radius:10px;
      padding:8px 10px;
      cursor:pointer;
      font-family:inherit;
    }
    button:hover{ border-color:#3c5664; }

    .main{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:10px;
      align-items:start;
    }
    @media (max-width: 980px){
      .main{ grid-template-columns: 1fr; }
      .controls{ white-space:normal; max-width: 100%; }
    }

    #screen{
      white-space:pre;
      font-size:14px;
      user-select:none;
      overflow:auto;
      /* more vertical room for map */
      min-height: 325px;
      max-height: 325px;
      
  		line-height:0.9;
  		letter-spacing:0.2em;
  		
  		font-family:
		    "JetBrains Mono",
		    "Cascadia Mono",
		    "Fira Code",
		    Consolas,
		    monospace;
    }

    .logline{ opacity:.92; }
    .dim { opacity:.35; }

    .legend h3, .log h3 { margin:0 0 8px 0; font-size:14px; }
    .legend-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px;
      font-size:12px;
    }
    .legend-item{
      display:flex;
      gap:8px;
      align-items:baseline;
      padding:4px 6px;
      border:1px solid #1b2a33;
      border-radius:10px;
      background:#0b1115;
    }
    .glyph{
      min-width: 18px;
      text-align:center;
      font-weight:700;
    }
    .legend-note{
      margin-top:8px;
      font-size:11px;
      opacity:.9;
      border-top:1px solid #1b2a33;
      padding-top:8px;
      line-height:1.25;
    }
    .footer-note{
      margin-top:10px;
      font-size:12px;
      opacity:.85;
    }
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #2a3b45;
      background:#0b1115;
      font-size:12px;
      margin-left:6px;
    }
    .promptline{
      margin-top:8px;
      padding:8px 10px;
      border:1px solid #2a3b45;
      border-radius:12px;
      background:#0b1115;
      font-size:12px;
    }

    /* Effects as inline chips */
    .effects{
      display:inline-flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
      margin:0;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #2a3b45;
      background:#0b1115;
      font-size:12px;
      white-space:nowrap;
      opacity:.95;
    }

    /* Collapsible legend */
    .legend-toggle{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:#0b1115;
      color:#cfd8dc;
      border:1px solid #2a3b45;
      border-radius:10px;
      padding:8px 10px;
      cursor:pointer;
      font-family:inherit;
      font-size:13px;
    }
    .legend-toggle:hover{ border-color:#3c5664; }
    .legend-body[data-collapsed="true"]{ display:none; }
    .chev{
      display:inline-block;
      transition: transform 120ms ease;
    }
    .legend-toggle[aria-expanded="true"] .chev{ transform: rotate(180deg); }


    /* Mute button (music) */
    .mute-btn{
      margin-left: 18px; /* not too close to Reset */
      width: 44px;
      height: 36px;
      border-radius: 12px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
    }
    .mute-btn.is-muted{
      opacity: .75;
    }

  #screenWrap{ position: relative; width: 100%; }
  #screenCanvas{ display:none; width:100%; height:auto; border-radius: 10px; background:#0b0f12; image-rendering: pixelated; }
  .ascii-screen{ white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="panel header">
        <div class="header-left">
          <div class="hud" id="hud"></div>
          <div class="controls" title="Controls">
            Move: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> & diagonals <kbd>Q</kbd><kbd>E</kbd><kbd>Z</kbd><kbd>C</kbd>
            ¬∑ Wait <kbd>.</kbd> ¬∑ Descend <kbd>&gt;</kbd> ¬∑ Heal/Drink <kbd>P</kbd> ¬∑ Potions <kbd>0</kbd>/<kbd>1</kbd>/<kbd>2</kbd>/<kbd>3</kbd>/<kbd>4</kbd>
            ¬∑ Trader prompt: <kbd>Y</kbd>/<kbd>N</kbd> + <kbd>A</kbd>/<kbd>B</kbd>
          </div>
        </div>
        <div class="header-right">
          <button id="restartBtn">Reset</button>
          <button id="muteBtn" class="mute-btn" title="Mute / unmute music" aria-pressed="false">üîä</button>
          <button id="skipBtn" class="skip-btn" title="Skip current track" aria-label="Skip track">‚è≠</button>
          <button id="tilesBtn" class="skip-btn" title="Tiles mode" aria-label="Tiles mode">Tiles</button>
          <button id="asciiBtn" class="skip-btn" title="ASCII mode" aria-label="ASCII mode">ASCII</button>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="panel">
        <div id="screenWrap" aria-label="game screen">
  <canvas id="screenCanvas"></canvas>
  <div id="screen" class="ascii-screen"></div>
</div>
        <div class="panel log" style="margin-top:10px;" id="log"></div>
        <div class="promptline" id="prompt"></div>
        <div class="footer-note">
          Tips:
          doors <span class="pill">#</span>/<span class="pill">/</span> block chokepoints until opened by bumping,
          locked doors <span class="pill">X</span> need keys from chests <span class="pill">$</span> (or can be forced),
          torches <span class="pill">t</span> restore sight (carry 2),
          traders <span class="pill" style="border-color:#ffd166;color:#ffd166;">T</span> sell goods.
        </div>
      </div>

      <div class="panel legend">
        <button class="legend-toggle" id="legendToggle" aria-expanded="true">
          <span><b>Legend</b></span>
          <span class="chev">‚ñæ</span>
        </button>
        <div class="legend-body" id="legendBody" style="margin-top:10px;">
          <div id="legend" class="legend-grid"></div>
          <div class="legend-note" id="legendNote"></div>
        </div>
      </div>
    </div>
  </div>

  <audio id="bgm" src="dungeons deep.mp3" preload="auto"></audio>

<script>
var game = null;
// --- Early init to avoid TDZ ---
var TILE_PX = 24;

  // Render mode must be initialized before any startup calls
  var RENDER_MODE = "tiles";

(() => {
  // --------- DIAGNOSTICS (so a blank screen tells us why) ---------
  const $diag = document.createElement('div');
  $diag.style.cssText = [
    'position:fixed',
    'left:10px',
    'bottom:10px',
    'max-width:min(900px,95vw)',
    'z-index:99999',
    'display:none',
    'padding:10px 12px',
    'border-radius:12px',
    'border:1px solid rgba(255,80,80,.55)',
    'background:rgba(20,10,10,.92)',
    'color:#ffd0d0',
    'font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
    'white-space:pre-wrap'
  ].join(';');
  document.addEventListener('DOMContentLoaded', () => document.body.appendChild($diag));

  function showDiag(title, detail){
    try{
      $diag.style.display = 'block';
      $diag.textContent = `${title}\n\n${detail || ''}`;
    }catch(_){/* ignore */}
  }

  window.addEventListener('error', (e) => {
    const msg = e?.message || 'Unknown error';
    const where = `${e?.filename || ''}:${e?.lineno || ''}:${e?.colno || ''}`;
    showDiag('Runtime Error', `${msg}\n${where}`);
  });
  window.addEventListener('unhandledrejection', (e) => {
    showDiag('Unhandled Promise Rejection', String(e?.reason || e));
  });

  // ============================================================
  // DUNGEONS DEEP ‚Äî Drop-in HTML
  // Key change (per request): keys are primarily stored in chests
  // so opening a chest grants a "keychain" all at once.
  // ============================================================

  // ---------- CONFIG ----------
  const DEBUG = false; // default ON: start with a full potion belt for testing

  const MAP_W = 80, MAP_H = 28;
  const VIEW_W = 60, VIEW_H = 18;

  // Vision (torch system)
  const VISION_DARK = 2;
  const VISION_DEFAULT = 8;
  const TORCH_CAP = 2;
  const TORCH_BURN_MOVES = 40;
  const TORCH_DIM_STEP_MOVES = 5;

  const ROOM_ATTEMPTS = 140;
  const ROOMS_MIN = 8, ROOMS_MAX = 14;
  const ROOM_W = [5, 13], ROOM_H = [4, 9];

  // Secret content tuning
  const SECRET_ROOM_MIN = 1;
  const SECRET_ROOM_MAX = 3;
  const SECRET_REVEAL_CHANCE = 0.50;
  const SECRET_SHORTCUT_CHANCE = 0.20;
  const SECRET_TRAP_MULT = 2.2;
  const SECRET_REWARD_MULT = 2;

  // Trader tuning
  const TRADER_SPAWN_CHANCE = 0.22;
  const TRADER_POTION_COST = 12;
  const TRADER_WEAPON_COST = 25;
  const TRADER_WEAPON_ATK_BONUS = 1;

  const POTION_CAP = 30;
const DEFAULT_HEAL_POTIONS = 3; // starting healing potions (non-debug)
  const KEY_CAP = 5;


  // Vitality Shrines
  const MAX_HP_CAP = 32;
  const VITALITY_SHRINE_CHANCE = 0.40; // per level (max 1)
  const SHRINE_BASE_GOLD_COST = 25;
  const SHRINE_GOLD_PER_LEVEL = 2;
  // Door tuning
  const DOOR_CHANCE = 0.22;
  const LOCKED_DOOR_CHANCE = 0.28;

  // Locked-door safety valve
  const LOCKED_DOOR_BREAKS_WITHOUT_KEY = true;
  const LOCK_BREAK_DAMAGE = 2;

  // Torches spawn ‚Äúfairly liberally‚Äù
  const TORCH_BASE_COUNT = 4;
  const TORCH_PER_LEVEL_BONUS = 1;
  const TORCH_BONUS_EVERY_LEVELS = 4;

  // Potion tuning
  const POTION_HEAL_RANGE = [6, 10];
  const POISON_STEPS = 5;
  const POISON_DMG_RANGE = [1, 2];
  const INVIS_STEPS = 35;
  const TRANSMUTE_STEPS = 20;
  const INVINCIBLE_STEPS = 40;

  // ---------- GLYPHS ----------
  const TILE = {
    ROCK: ' ',
    FLOOR: '.',
    CORR: ',',
    DOOR_C: '#',
    DOOR_O: '/',
    LDOOR_C: 'X',
    LDOOR_O: '/',
    SD_C: 'S',
    SD_O: 's',
    DOWN: '>',
    SDOWN: '¬ª'
  };

  const ENT = {
    PLAYER: '*',
    POTION: '!',
    CHEST: '$',
    WEAPON: '∆™',
    TRAP: '^',
    TRADER: 'T',
    TORCH: 't',

    SHRINE: '¬•',
    GOBLIN: 'g',
    ORC: 'o',
    SNAKE: '~',
    CUBE: 'O',
    DRAGON: 'œ†',
    CRAWLER: '∆∫',
    WALKER: '—™',
    WRAITH: 'œ£',
    HORROR: '∆ü'
  };

  // Potion types
  const POTION = {
    HEAL: "heal",
    POISON: "poison",
    INVIS: "invis",
    TRANSMUTE: "transmute",
    INVINC: "invinc",
    TELE: "tele"};

  // ---------- COLORS ----------
  const COL = {
    fg: '#cfd8dc',
    wall: '#9fb3bf',
    floor: '#93a4ad',
    corr: '#7f8f98',
    door: '#ffd166',
    locked: '#ffb703',
    sdoor: '#c8b6ff',
    stairs: '#4dd0e1',
    shortcut: '#80cbc4',

    chest: '#f6f740',
    weapon: '#a7ffeb',
    trap: '#ff5252',
    torch: '#ffcf6b',

    shrine: "#9be7ff",
    potion_purple: '#ff6bd6',
    potion_green:  '#68ff79',
    potion_grey:   '#b0bec5',
    potion_ochre:  '#d4a373',
    potion_red:    '#ff4d4d',

    monster: '#ff6b6b',
    boss: '#ff8a65',
    player: '#ffffff',
    trader: '#ffd166',
    dim: '#6b7b84',
    rock: '#0b0f12'
  };

  const MONSTER_COLOR = {
    [ENT.GOBLIN]: COL.monster,
    [ENT.ORC]: COL.monster,
    [ENT.SNAKE]: '#66ff66',
    [ENT.CUBE]: '#55aaff',
    [ENT.DRAGON]: '#ff4444',
    [ENT.CRAWLER]: '#ffb347',
    [ENT.WALKER]: '#f5f5f5',
    [ENT.WRAITH]: '#bbaaff',
    [ENT.HORROR]: COL.boss
  };

  const POTION_COLOR = {
    [POTION.HEAL]: COL.potion_purple,
    [POTION.POISON]: COL.potion_green,
    [POTION.INVIS]: COL.potion_grey,
    [POTION.TRANSMUTE]: COL.potion_ochre,
    [POTION.INVINC]: COL.potion_red,
    [POTION.TELE]: "#7f8cff"};

  const POTION_NAME = {
    [POTION.HEAL]: "Healing",
    [POTION.POISON]: "Poison",
    [POTION.INVIS]: "Invisibility",
    [POTION.TRANSMUTE]: "Transmutation",
    [POTION.INVINC]: "Invincibility",
    [POTION.TELE]: "Teleportation"};

  const GLYPH_REGISTRY = [
    { glyph: ENT.PLAYER, name: "Player", color: COL.player },
    { glyph: '+', name: "Wall +", color: COL.wall },
    { glyph: '‚Äì', name: "Wall ‚Äì", color: COL.wall },
    { glyph: '|', name: "Wall |", color: COL.wall },
    { glyph: TILE.FLOOR, name: "Floor", color: COL.floor },
    { glyph: TILE.CORR, name: "Hall", color: COL.corr },

    { glyph: TILE.DOOR_C, name: "Door", color: COL.door },
    { glyph: TILE.DOOR_O, name: "Open", color: COL.door },
    { glyph: TILE.LDOOR_C, name: "Locked", color: COL.locked },

    { glyph: ENT.TORCH, name: "Torch", color: COL.torch },

    { glyph: ENT.SHRINE, name: "Vitality Shrine", color: COL.shrine },

    { glyph: TILE.SD_C, name: "Secret", color: COL.sdoor },
    { glyph: TILE.SD_O, name: "Open", color: COL.sdoor },
    { glyph: TILE.DOWN, name: "Down", color: COL.stairs },
    { glyph: TILE.SDOWN, name: "Skip", color: COL.shortcut },

    { glyph: ENT.TRADER, name: "Trader", color: COL.trader },

    { glyph: ENT.POTION, name: "Heal (purple)", color: POTION_COLOR[POTION.HEAL] },
    { glyph: ENT.POTION, name: "Poison (green)", color: POTION_COLOR[POTION.POISON] },
    { glyph: ENT.POTION, name: "Invis (grey)", color: POTION_COLOR[POTION.INVIS] },
    { glyph: ENT.POTION, name: "Trans (ochre)", color: POTION_COLOR[POTION.TRANSMUTE] },
    { glyph: ENT.POTION, name: "Invinc (red)", color: POTION_COLOR[POTION.INVINC] },

    { glyph: ENT.CHEST, name: "Chest", color: COL.chest },
    { glyph: ENT.WEAPON, name: "Weapon", color: COL.weapon },
    { glyph: ENT.TRAP, name: "Trap", color: COL.trap },

    { glyph: ENT.GOBLIN, name: "Goblin", color: MONSTER_COLOR[ENT.GOBLIN] },
    { glyph: ENT.ORC, name: "Orc", color: MONSTER_COLOR[ENT.ORC] },
    { glyph: ENT.SNAKE, name: "Snake", color: MONSTER_COLOR[ENT.SNAKE] },
    { glyph: ENT.CUBE, name: "Cube", color: MONSTER_COLOR[ENT.CUBE] },
    { glyph: ENT.DRAGON, name: "Dragon", color: MONSTER_COLOR[ENT.DRAGON] },
    { glyph: ENT.CRAWLER, name: "Crawler", color: MONSTER_COLOR[ENT.CRAWLER] },
    { glyph: ENT.WALKER, name: "Walker", color: MONSTER_COLOR[ENT.WALKER] },
    { glyph: ENT.WRAITH, name: "Wraith", color: MONSTER_COLOR[ENT.WRAITH] },
    { glyph: ENT.HORROR, name: "Horror", color: MONSTER_COLOR[ENT.HORROR] }
  ];

  const LEGEND_NOTE = `
    Visible tiles are bright; remembered tiles are dim.<br/>
    Start in darkness (vision ${VISION_DARK}). Torches restore vision and then dim as moves are made (carry ${TORCH_CAP}).<br/>
    Locked doors (X) can be unlocked with keys (now stored in chests), or forced with HP cost.<br/>
    Potions share glyph (!) but have different colors/effects. Effects tick on movement steps.
  `;

  // ---------- UI ----------
  const $screenAscii = document.getElementById('screen');
  const $screenCanvas = document.getElementById('screenCanvas');
  const $hud = document.getElementById('hud');
  const $log = document.getElementById('log');
  const $prompt = document.getElementById('prompt');
  const $restartBtn = document.getElementById('restartBtn');
  const $legend = document.getElementById('legend');
  const $legendNote = document.getElementById('legendNote');


  // ---------- AUDIO + MUSIC ENGINE ----------
  // Single-channel BGM player that can switch between base theme and situational clips.
  const $bgm = document.getElementById('bgm');
  const $muteBtn = document.getElementById('muteBtn');
  const $skipBtn = document.getElementById('skipBtn');
  const $tilesBtn = document.getElementById('tilesBtn');
  const $asciiBtn = document.getElementById('asciiBtn');
  let uiMuted = (localStorage.getItem("dd_muted") === "1"); // persisted
  let pendingPlay = false;

  // Music catalog (scale-friendly: add more pools/triggers as you create clips)
  const INTRO_LOCK_MS = 45000; // minimum time before triggers (45s)
  const SKIP_PLAYLIST = [
    "dungeons deep.mp3",
    "music_active.mp3",
    "music_active2.mp3",
    "music_medium2.mp3",
    "music_medium3.mp3",
    "music_slow1.mp3",
    "music_slow2.mp3",
    "music_slow3.mp3",
  ];

  const Music = {
    base: { src: "dungeons deep.mp3", loop: true },

    // pools = collections of clips that a trigger may pick from
    pools: {
      active: [
        { src: "music_active.mp3", weight: 1 },
        { src: "music_active2.mp3", weight: 1 }
      ],
      medium: [
        { src: "music_medium2.mp3", weight: 1 },
        { src: "music_medium3.mp3", weight: 1 }
      ],
      slow: [
        { src: "music_slow1.mp3", weight: 1 },
        { src: "music_slow2.mp3", weight: 1 },
        { src: "music_slow3.mp3", weight: 1 }
      ],

      // Mixed roaming pool: mostly slow, occasionally medium
      roam: [
        { src: "music_slow1.mp3",   weight: 3 },
        { src: "music_slow2.mp3",   weight: 3 },
        { src: "music_slow3.mp3",   weight: 3 },
        { src: "music_medium2.mp3", weight: 1 },
        { src: "music_medium3.mp3", weight: 1 }
      ],
      transitions: [
        { src: "music2_transitions_descending.mp3", weight: 1 }
      ]
    },

    // triggers = rule definitions (probability + cooldown + pool)
    triggers: {
      monsterEncounter: { prob: 0.50, cooldownMs: 8000, pool: "active" },
      roam:            { prob: 0.20, cooldownMs: 12000, pool: "roam" },
      descend:         { prob: 1.00, cooldownMs: 0,     pool: "transitions" }
    },

    state: {
      mode: "base", // "base" | "clip"
      skipIndex: 0,
      introPlaying: true,
      introStart: 0,
      pending: [],
      pendingTimer: null,
      lastFire: { monsterEncounter: 0, roam: 0 }
    }
  };

  
  function musicAllTracks(){
    const seen = new Set();
    const out = [];

    // base first
    if(Music.base && Music.base.src){
      seen.add(Music.base.src);
      out.push(Music.base.src);
    }

    // pools in stable order
    const poolOrder = Object.keys(Music.pools || {});
    for(const poolName of poolOrder){
      const pool = Music.pools[poolName] || [];
      for(const it of pool){
        const src = it && it.src;
        if(src && !seen.has(src)){
          seen.add(src);
          out.push(src);
        }
      }
    }
    return out;
  }

  function musicSkipNext(){
    if(!$bgm) return;

    // Skipping is a user action: clear intro locks so cycling is responsive.
    Music.state.introPlaying = false;
    Music.state.introStart = 0;

    // Advance deterministic playlist index
    Music.state.skipIndex = (Music.state.skipIndex || 0) + 1;
    const idx = Music.state.skipIndex % SKIP_PLAYLIST.length;
    const next = SKIP_PLAYLIST[idx];

    // Treat base theme as looping, all others as clips (non-loop)
    const isBase = (next === (Music.base && Music.base.src));
    Music.state.mode = isBase ? "base" : "clip";

    musicSetSrcHard(next, isBase);

    try{ $bgm.currentTime = 0; }catch(e){}
    musicPlay();
  }

function setMuted(v){
    uiMuted = !!v;
    localStorage.setItem("dd_muted", uiMuted ? "1" : "0");
    if($bgm) $bgm.muted = uiMuted;
    if($muteBtn){
      $muteBtn.classList.toggle("is-muted", uiMuted);
      $muteBtn.setAttribute("aria-pressed", uiMuted ? "true" : "false");
      $muteBtn.textContent = uiMuted ? "üîá" : "üîä";
    }
    if(uiMuted && $bgm) $bgm.pause();
  }

  function weightedPick(arr){
    const total = arr.reduce((s,it)=>s+(it.weight||1),0);
    let r = Math.random()*total;
    for(const it of arr){
      r -= (it.weight||1);
      if(r <= 0) return it;
    }
    return arr[arr.length-1];
  }

  function musicSetSrc(src, loop){
    if(!$bgm) return;
    if($bgm && !$bgm.paused){ try{$bgm.pause();}catch(e){} }
    if($bgm.getAttribute("src") !== src){
      $bgm.setAttribute("src", src);
      $bgm.load();
    }
    $bgm.loop = !!loop;
  }


  function musicSetSrcHard(src, loop){
    if(!$bgm) return;
    try{ $bgm.pause(); }catch(e){}
    // Use property assignment so currentSrc updates reliably
    $bgm.src = src;
    $bgm.loop = !!loop;
    try{ $bgm.load(); }catch(e){}
  }
  function musicPlay(){
    if(!$bgm || uiMuted) return;
    const p = $bgm.play();
    if(p && typeof p.catch === "function"){
      p.catch(() => { pendingPlay = true; });
    }
  }

  function playTheme(){
    if(!$bgm || uiMuted) return;

    // Intro lock: let the theme play through once before any other music can trigger
    Music.state.mode = "base";
    Music.state.introPlaying = true;
    Music.state.introStart = Date.now();
    musicSetSrc(Music.base.src, false); // play once (no loop) for the intro
    try{ $bgm.currentTime = 0; }catch(e){}
    musicPlay();

    // fresh run
    Music.state.lastFire.monsterEncounter = 0;
    Music.state.lastFire.roam = 0;
    Music.state.skipIndex = -1;
  }

  function playClip(src){
    if(!$bgm || uiMuted) return;
    Music.state.mode = "clip";
    musicSetSrc(src, false);
    try{ $bgm.currentTime = 0; }catch(e){}
    musicPlay();
  }

  function resumeBase(){
    if(!$bgm) return;
    Music.state.mode = "base";
    Music.state.introPlaying = false;
    musicSetSrc(Music.base.src, true);
    musicPlay();
  }

  
  function queueMusicTrigger(triggerName, retryInMs){
    //logMsg(`[Music] Queued ${triggerName}`);
    // de-dupe
    if(!Music.state.pending.includes(triggerName)){
      Music.state.pending.push(triggerName);
    }
    // schedule a retry when the lock is likely to clear
    if(Music.state.pendingTimer) return;
    const wait = Math.max(250, Math.min(60000, retryInMs || 1000));
    Music.state.pendingTimer = setTimeout(() => {
      Music.state.pendingTimer = null;
      processPendingMusicTriggers();
    }, wait);
  }

  function processPendingMusicTriggers(){
    if(!$bgm || uiMuted) return;
    if(Music.state.mode === "clip") return;

    // If still in intro, keep waiting
    if(Music.state.introStart){
      const elapsed = Date.now() - Music.state.introStart;
      if(elapsed < INTRO_LOCK_MS || Music.state.introPlaying){
        queueMusicTrigger(Music.state.pending[0] || "roam", INTRO_LOCK_MS - elapsed);
        return;
      }
    }

    // Try pending triggers in FIFO order
    while(Music.state.pending.length){
      const tname = Music.state.pending.shift();
      // Try without queue to avoid infinite loops
      musicMaybeTrigger(tname, false);
      if(Music.state.mode === "clip") break;
    }
  }
function musicMaybeTrigger(triggerName, allowQueue=false){
    if(!$bgm || uiMuted) return;

    const t = Music.triggers[triggerName];
    if(!t) return;

    const now = Date.now();
    const last = Music.state.lastFire[triggerName] || 0;
    if(now - last < t.cooldownMs) return;

    // Hard intro time lock: do not allow situational music before minimum time
    if(Music.state.introStart){
      const elapsed = Date.now() - Music.state.introStart;
      if(elapsed < INTRO_LOCK_MS){
        if(allowQueue) queueMusicTrigger(triggerName, INTRO_LOCK_MS - elapsed);
        return;
      }
    }

    // Soft intro lock: even after 45s, do not interrupt until the intro has finished
    if(Music.state.introPlaying){
      if(allowQueue) queueMusicTrigger(triggerName, 1000);
      return;
    }

    // Don't interrupt a currently-playing clip
    if(Music.state.mode === "clip") return;

    if(Math.random() > t.prob) return;

    const pool = Music.pools[t.pool] || [];
    if(pool.length === 0) return;

    const pick = weightedPick(pool);
    Music.state.lastFire[triggerName] = now;
    playClip(pick.src);
  }

  // When a situational clip ends, return to base theme
  
  function handleBgmEnded(){

      // If a situational clip ended, return to base loop
      if(Music.state.mode === "clip"){
        resumeBase();
        return;
      }

      // If the base intro finished, switch to looping base theme
      if(Music.state.mode === "base" && Music.state.introPlaying){
        Music.state.introPlaying = false;
        Music.state.introStart = 0;
        musicSetSrc(Music.base.src, true);
        try{ $bgm.currentTime = 0; }catch(e){}
        musicPlay();
      }
    
  }
  if($bgm){
    $bgm.addEventListener("ended", handleBgmEnded);
  }


  // Autoplay fallback: retry once user interacts (browser policy)
  (function armAutoplayFallback(){
    const kick = () => {
      if(!pendingPlay) return;
      pendingPlay = false;
      musicPlay();
      window.removeEventListener("keydown", kick, true);
      window.removeEventListener("mousedown", kick, true);
      window.removeEventListener("touchstart", kick, true);
    };
    window.addEventListener("keydown", kick, true);
    window.addEventListener("mousedown", kick, true);
    window.addEventListener("touchstart", kick, true);
  })();

  // Mute toggle (one-click unmute + immediate playback)
  if($muteBtn){
    $muteBtn.addEventListener("click", (e) => {
      e.preventDefault();
      const nextMuted = !uiMuted;
      setMuted(nextMuted);
      if(!nextMuted){
        musicPlay();
      }
    });
  }
  
  // Skip button: jump to end of current track (intro/clip/base). Useful for testing.
  if($skipBtn){
    $skipBtn.addEventListener("click", (e) => {
      e.preventDefault();
      musicSkipNext();
    });
  }


  // Render mode buttons
  if($tilesBtn){
    $tilesBtn.addEventListener("click", (e) => {
      e.preventDefault();
      setRenderMode("tiles");
    });
  }
  if($asciiBtn){
    $asciiBtn.addEventListener("click", (e) => {
      e.preventDefault();
      setRenderMode("ascii");
    });
  }

setMuted(uiMuted);
  // Default renderer on load
  RENDER_MODE = "tiles";
// ---------- SFX ENGINE (plays over music) ----------
  // WebAudio-based (more reliable than <audio> nodes across browsers) + easy to extend.
  const SFX_MASTER = 0.55; // global SFX loudness (0..1)

  const SFX_DEFS = {
    step:    { src: "sfx_step.wav",        vol: 0.35 },
    bump:    { src: "sfx_wall_bump.wav",   vol: 0.55 },
    pickup:  { src: "sfx_pickup.wav",      vol: 0.55 },
    drink:   { src: "sfx_drink.wav",       vol: 0.50 },
    attack:  { src: "sfx_attack.wav",      vol: 0.60 },
    damage:  { src: "sfx_damage.wav",      vol: 0.70 },
    descend: { src: "sfx_descend.wav",     vol: 0.60 },
    wait:    { src: "sfx_wait.wav",        vol: 0.30 }
  };

  let sfxCtx = null;
  let sfxMasterGain = null;
  const sfxBuffers = {}; // name -> AudioBuffer
  let sfxReady = false;

  async function initSfxWebAudio(){
    try{
      sfxCtx = new (window.AudioContext || window.webkitAudioContext)();
      sfxMasterGain = sfxCtx.createGain();
      sfxMasterGain.gain.value = Math.max(0, Math.min(1, SFX_MASTER));
      sfxMasterGain.connect(sfxCtx.destination);

      const entries = Object.entries(SFX_DEFS);
      for(const [name, def] of entries){
        const resp = await fetch(def.src, { cache: "no-store" });
        const arr = await resp.arrayBuffer();
        const buf = await sfxCtx.decodeAudioData(arr);
        sfxBuffers[name] = buf;
      }
      sfxReady = true;
    }catch(e){
      console.warn("SFX WebAudio init failed (check wav paths / browser):", e);
      sfxReady = false;
    }
  }

  function ensureSfxContextResumed(){
    if(!sfxCtx) return;
    if(sfxCtx.state === "suspended"){
      sfxCtx.resume().catch(()=>{});
    }
  }

  function playSfx(name){
    if(uiMuted) return;
    if(!sfxReady || !sfxCtx) return;
    const buf = sfxBuffers[name];
    if(!buf) return;

    ensureSfxContextResumed();

    const src = sfxCtx.createBufferSource();
    src.buffer = buf;

    const g = sfxCtx.createGain();
    const vol = (SFX_DEFS[name]?.vol ?? 0.5);
    g.gain.value = Math.max(0, Math.min(1, vol));

    src.connect(g);
    g.connect(sfxMasterGain);

    try{ src.start(0); }catch(e){}
  }

  // Kick off loading immediately; actual playback requires a user gesture to resume AudioContext (handled below).
  initSfxWebAudio();

  // Resume SFX context on first user gesture (keydown/click/touch)
  (function armSfxGestureResume(){
    const kick = () => {
      ensureSfxContextResumed();
      window.removeEventListener("keydown", kick, true);
      window.removeEventListener("mousedown", kick, true);
      window.removeEventListener("touchstart", kick, true);
    };
    window.addEventListener("keydown", kick, true);
    window.addEventListener("mousedown", kick, true);
    window.addEventListener("touchstart", kick, true);
  })();

  // Tiny self-test: press "V" to play a pickup sound (does not affect gameplay)
  window.addEventListener("keydown", (e) => {
    if(e.key === "v" || e.key === "V"){
      playSfx("pickup");
    }
  }, true);

// legend collapse controls
  const $legendToggle = document.getElementById('legendToggle');
  const $legendBody = document.getElementById('legendBody');
  let legendCollapsed = localStorage.getItem("dd_legend_collapsed") === "1";
  function setLegendCollapsed(v){
    legendCollapsed = v;
    $legendBody.setAttribute('data-collapsed', legendCollapsed ? 'true' : 'false');
    $legendToggle.setAttribute('aria-expanded', legendCollapsed ? 'false' : 'true');
    localStorage.setItem("dd_legend_collapsed", legendCollapsed ? "1" : "0");
  }
  $legendToggle.addEventListener('click', () => setLegendCollapsed(!legendCollapsed));
  setLegendCollapsed(legendCollapsed);

  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function renderLegend(){
    $legend.innerHTML = GLYPH_REGISTRY.map(row => {
      const g = row.glyph === ' ' ? '&nbsp;' : escapeHtml(row.glyph);
      return `
        <div class="legend-item">
          <div class="glyph" style="color:${row.color}">${g}</div>
          <div>${escapeHtml(row.name)}</div>
        </div>
      `;
    }).join('');
    $legendNote.innerHTML = LEGEND_NOTE;
  }

  // ---------- HELPERS ----------
  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function choice(arr){ return arr[randInt(0, arr.length-1)]; }


function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*total;
  for(let i=0;i<items.length;i++){
    r -= weights[i];
    if(r <= 0) return items[i];
  }
  return items[items.length-1];
}



  function shuffleInPlace(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function chance(p){ return Math.random() < p; }
  function keyXY(x,y){ return `${x},${y}`; }
  function parseKey(k){ const [x,y]=k.split(',').map(Number); return {x,y}; }

  // Consume a specific potion type regardless of pickup order (no FIFO/LIFO).
  function consumePotionByType(type){
    const inv = game.inv.potions;
    if(!Array.isArray(inv) || inv.length === 0) return false;
    const idx = inv.indexOf(type);
    if(idx === -1) return false;
    inv.splice(idx, 1);
    return true;
  }

  function debugFillPotions(){
    // Fill the potion belt to POTION_CAP with a balanced mix (healing favored).
    game.inv.potions.length = 0;

    // Target mix totals to exactly POTION_CAP (adjusts automatically if cap changes).
    const target = {
      [POTION.HEAL]: Math.round(POTION_CAP * 0.36),
      [POTION.POISON]: Math.round(POTION_CAP * 0.16),
      [POTION.INVIS]: Math.round(POTION_CAP * 0.16),
      [POTION.TRANSMUTE]: Math.round(POTION_CAP * 0.14),
      [POTION.INVINC]: Math.round(POTION_CAP * 0.13),
      [POTION.TELE]: Math.round(POTION_CAP * 0.05),
    };

    // Normalize in case rounding drifts.
    let total = Object.values(target).reduce((a,b)=>a+b,0);
    while(total > POTION_CAP){ target[POTION.HEAL]--; total--; }
    while(total < POTION_CAP){ target[POTION.HEAL]++; total++; }

    for(const [type, n] of Object.entries(target)){
      for(let i=0;i<n;i++) game.inv.potions.push(type);
    }
  }



  function countPotionsByType(){
    const counts = {
      [POTION.HEAL]: 0,
      [POTION.POISON]: 0,
      [POTION.INVIS]: 0,
      [POTION.TRANSMUTE]: 0,
      [POTION.INVINC]: 0,
      [POTION.TELE]: 0};
    for(const p of game.inv.potions){
      if(p in counts) counts[p] += 1;
    }
    return counts;
  }

  function makeGrid(w,h, fill){
    const g = new Array(w);
    for(let x=0;x<w;x++){
      g[x] = new Array(h);
      for(let y=0;y<h;y++) g[x][y] = fill;
    }
    return g;
  }

  // ---------- GAME STATE ----------
  var game = null;

  function newGame(){
    game = {
      depth: 1,
      maxDepth: 20,
      hpMax: 18,
      hp: 18,
      restFrac: 0,
      restHealedThisLevel: 0,
      
      restCapMsgShown: false,
      atk: 3,
      weaponName: "Bare Hands",
      weaponEquipped: false,
      gold: 0,
      inv: {
        potions: [],
        keys: 0,
        torches: 0
      },
      effects: {
        poison: 0,
        invis: 0,
        transmute: 0,
        invincible: 0
      },
      torch: {
        lit: false,
        radius: VISION_DARK,
        burnLeft: 0,
        dimStepLeft: 0
      },
      msg: [],
      levels: {},
      prompt: null,
      slimeWait: false,
      ended: false,
      victory: null
    };


    // Default starting supplies
    for(let i=0;i<DEFAULT_HEAL_POTIONS;i++) game.inv.potions.push(POTION.HEAL);
    if(DEBUG){
      debugFillPotions();
      logMsg("DEBUG: Potion belt filled for testing.");
    }

    loadLevel(1);
    logMsg("Welcome to DUNGEONS DEEP.");
    logMsg(`It is dark. Vision is only ${VISION_DARK}. Find a torch (t).`);
    logMsg("Keys are found in chests ($). Open one to grab a keychain.");
    renderAll();
  }

  function endGameWin(){
    if(game.ended) return;
    game.ended = true;
    game.victory = true;
    logMsg("you win!");
    logMsg("Reset to play again.");
    renderAll(true);
  }

  function endGameLose(){
    if(game.ended) return;
    game.ended = true;
    game.victory = false;
    logMsg("Defeat ‚Äî the depths claim another explorer.");
    logMsg("Reset to try again.");
    renderAll(true);
  }

  function setPrompt(p){ game.prompt = p; renderPrompt(); }
  function clearPrompt(){ game.prompt = null; renderPrompt(); }

  function renderPrompt(){
    if(!game.prompt){
      $prompt.innerHTML = `<span style="opacity:.85">No prompt.</span>`;
      return;
    }
    const p = game.prompt;
    if(p.type === 'trade'){
      $prompt.innerHTML =
        `<b style="color:${COL.trader}">Trader:</b> Trade gold? ` +
        `<span class="pill">A</span> Potion (${p.costPotion}g) ` +
        `<span class="pill">B</span> Weapon (+${p.atkBonus} ATK, ${p.costWeapon}g)` +
        ` ‚Äî Buy? <b>Y/N</b> (default N if leaving).`;
    } else if(p.type === 'shrine'){
      $prompt.innerHTML =
        `<b style="color:${COL.shrine}">Shrine:</b> Gain +1 Max HP at a cost? <b>Y/N</b> (default N if leaving).`;
    } else {
      $prompt.innerHTML = `<span style="opacity:.85">Prompt active.</span>`;
    }
  }

  function logMsg(s){
    game.msg.unshift(s);
    game.msg = game.msg.slice(0, 7);
    const lines = game.msg.map(m => `<div class="logline">${escapeHtml(m)}</div>`).join('');
    $log.innerHTML = `<h3>Messages</h3>${lines}`;
  }

  function getLevel(depth){ return game.levels[depth]; }
  function setLevel(depth, lvl){ game.levels[depth] = lvl; }

  function loadLevel(depth){
    let lvl = getLevel(depth);
    if(!lvl){
      lvl = generateLevel(depth);
      setLevel(depth, lvl);
    }
    game.depth = depth;
    game.restFrac = 0;
    game.restHealedThisLevel = 0;
    game.restCapMsgShown = false;
    lvl.player = { ...lvl.startPos };
    clearPrompt();
    computeFov(lvl);
  }

  // ---------- EFFECTS ----------
  function hasInvincible(){ return game.effects.invincible > 0; }
  function hasInvis(){ return game.effects.invis > 0; }
  function hasTransmute(){ return game.effects.transmute > 0; }

  function tickEffectsOnStep(){
    if(game.effects.poison > 0){
      const dmg = randInt(POISON_DMG_RANGE[0], POISON_DMG_RANGE[1]);
      if(!hasInvincible()){
        game.hp -= dmg;
        logMsg(`Poison burns. -${dmg} HP (${game.effects.poison-1} steps left).`);
        if(game.hp <= 0){
          game.hp = 0;
          endGameLose();
          return;
        }
      } else {
        logMsg(`Poison tries to bite‚Ä¶ but invincibility holds (${game.effects.poison-1}).`);
      }
      game.effects.poison--;
    }

    if(game.effects.invis > 0){
      game.effects.invis--;
      if(game.effects.invis === 0) logMsg("Invisibility fades.");
    }
    if(game.effects.transmute > 0){
      game.effects.transmute--;
      if(game.effects.transmute === 0) logMsg("Transmutation ends.");
    }
    if(game.effects.invincible > 0){
      game.effects.invincible--;
      if(game.effects.invincible === 0) logMsg("Invincibility fades.");
    }
  }

  // ---------- TORCH ----------
  
  // ---------- ENVIRONMENT MECHANICS ----------
  function envAt(lvl, x, y){
    if(!lvl.env || !lvl.env[x]) return 0;
    return lvl.env[x][y];
  }

  function handleWaterEffectsOnEnter(lvl){
    // Extinguish lit torch immediately
    if(game.torch.lit){
      game.torch.lit = false;
      game.torch.radius = VISION_DARK;
      game.torch.burnLeft = 0;
      game.torch.dimStepLeft = 0;
      logMsg("Water extinguishes your torch.");
    }

    // Drop any spare torches carried
    if(game.inv.torches > 0){
      const dropCount = game.inv.torches;
      game.inv.torches = 0;
      logMsg("You drop your saturated torches.");

      const p = lvl.player;
      const k = keyXY(p.x, p.y);
      if(lvl.items.has(k)){
        // If something already exists here, we just lose them (rare)
      } else {
        lvl.items.set(k, { type: ENT.TORCH, count: dropCount });
      }
    }
  }

  function applyEnvironmentOnEnter(lvl, prevX, prevY, newX, newY){
    const e = envAt(lvl, newX, newY);

    if(e === 'water'){
      // Flavor message + then apply torch/gear effects
      logMsg("Dank water flows from the ceiling to the floor.");
      handleWaterEffectsOnEnter(lvl);

    } else if(e === 'mist'){
      logMsg("An enveloping mist limits your vision");

    } else if(e === 'fire'){
      if(!hasInvincible()){
        game.hp -= 2;
        logMsg("Fire scorches you. -2 HP.");
        if(game.hp <= 0){
          game.hp = 0;
          endGameLose();
          return;
        }
      }
    }
    // Slime remains handled by the movement-slow logic (as-is)
  }
function currentVisionRadius(){
    const lvl = getLevel(game.depth);
    const p = lvl.player;
    const e = envAt(lvl, p.x, p.y);
    if(e === 'mist'){
      return game.torch.lit ? 1 : 0;
    }
    return game.torch.radius;
  }

  function startNewTorchBurn(){
    game.torch.lit = true;
    game.torch.radius = VISION_DEFAULT;
    game.torch.burnLeft = TORCH_BURN_MOVES;
    game.torch.dimStepLeft = TORCH_DIM_STEP_MOVES;
  }

  function maybeAutoLightTorch(){
    if(game.torch.lit) return;
    if(game.inv.torches <= 0) return;
    game.inv.torches--;
    startNewTorchBurn();
    logMsg("A torch flares to life. The darkness retreats.");
  }

  function extinguishTorch(){
    game.torch.lit = false;
    game.torch.radius = VISION_DARK;
    game.torch.burnLeft = 0;
    game.torch.dimStepLeft = 0;
    logMsg("The torch sputters out. Darkness returns.");
    maybeAutoLightTorch();
  }

  function advanceTorchOnMove(){
    if(!game.torch.lit) return;

    if(game.torch.burnLeft > 0){
      game.torch.burnLeft--;
      if(game.torch.burnLeft === 0){
        logMsg("The torch begins to dim...");
      }
      return;
    }

    game.torch.dimStepLeft--;
    if(game.torch.dimStepLeft > 0) return;

    game.torch.dimStepLeft = TORCH_DIM_STEP_MOVES;
    if(game.torch.radius > VISION_DARK){
      game.torch.radius--;
      if(game.torch.radius > VISION_DARK){
        logMsg(`The torch dims. Visibility now ${game.torch.radius}.`);
      } else {
        extinguishTorch();
      }
    } else {
      extinguishTorch();
    }
  }

  // ---------- GENERATION HELPERS ----------
  function rectsOverlapInflated(a,b,pad){
    const ax1=a.x-pad, ay1=a.y-pad, ax2=a.x+a.w+pad, ay2=a.y+a.h+pad;
    const bx1=b.x, by1=b.y, bx2=b.x+b.w, by2=b.y+b.h;
    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
  }

  function carveRoom(tiles, r, secretGrid=null){
    for(let x=r.x;x<r.x+r.w;x++){
      for(let y=r.y;y<r.y+r.h;y++){
        tiles[x][y] = TILE.FLOOR;
        if(secretGrid) secretGrid[x][y] = true;
      }
    }
  }

  function carveH(tiles, x1,x2,y, secretGrid=null){
    const [a,b] = x1<x2 ? [x1,x2] : [x2,x1];
    for(let x=a;x<=b;x++){
      if(tiles[x][y] === TILE.ROCK) tiles[x][y] = TILE.CORR;
      if(secretGrid) secretGrid[x][y] = true;
    }
  }

  function carveV(tiles, y1,y2,x, secretGrid=null){
    const [a,b] = y1<y2 ? [y1,y2] : [y2,y1];
    for(let y=a;y<=b;y++){
      if(tiles[x][y] === TILE.ROCK) tiles[x][y] = TILE.CORR;
      if(secretGrid) secretGrid[x][y] = true;
    }
  }

  function carveCorridor(tiles, x1,y1,x2,y2){
    if(Math.random()<0.5){
      carveH(tiles, x1,x2,y1);
      carveV(tiles, y1,y2,x2);
    } else {
      carveV(tiles, y1,y2,x1);
      carveH(tiles, x1,x2,y2);
    }
  }

  function findOpenSpot(tiles, room){
    for(let tries=0; tries<2000; tries++){
      const x = randInt(room.x+1, room.x+room.w-2);
      const y = randInt(room.y+1, room.y+room.h-2);
      const t = tiles[x][y];
      if(t===TILE.FLOOR || t===TILE.CORR) return {x,y};
    }
    for(let x=1;x<MAP_W-1;x++){
      for(let y=1;y<MAP_H-1;y++){
        const t = tiles[x][y];
        if(t===TILE.FLOOR || t===TILE.CORR) return {x,y};
      }
    }
    return {x:2,y:2};
  }

    function findRandomOpenTile(lvl){
    let x, y, tries = 0;
    do{
      x = randInt(1, MAP_W - 2);
      y = randInt(1, MAP_H - 2);
      tries++;
      if(tries > 4000) break;

      const k = keyXY(x,y);

      if(lvl.tiles[x][y] !== TILE.FLOOR) continue;
      if(lvl.player && lvl.player.x === x && lvl.player.y === y) continue;
      if(lvl.monsters && lvl.monsters.has && lvl.monsters.has(k)) continue;
      if(lvl.traders && lvl.traders.has && lvl.traders.has(k)) continue;

      return {x,y};
    }while(true);

    // fallback: keep current position
    return {x: lvl.player.x, y: lvl.player.y};
  }


  function scatter(map, tiles, count, makeObj, canPlaceFn=null, forbidFn=null){
    let placed=0;
    for(let tries=0; tries<25000 && placed<count; tries++){
      const x = randInt(2, MAP_W-3);
      const y = randInt(2, MAP_H-3);
      if(canPlaceFn && !canPlaceFn(x,y)) continue;
      if(forbidFn && forbidFn(x,y)) continue;

      const k = keyXY(x,y);
      if(map.has(k)) continue;

      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
      if(t===TILE.DOWN || t===TILE.SDOWN) continue;
      if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) continue;

      map.set(k, makeObj(x,y));
      placed++;
    }
  }

  function weaponNameForDepth(d){
    if(d<6) return "Short Sword";
    if(d<12) return "Long Sword";
    if(d<18) return "Runed Blade";
    return "Deepsteel Edge";
  }
  function weaponAtkForDepth(d){
    if(d<6) return 4;
    if(d<12) return 6;
    if(d<18) return 8;
    return 10;
  }

  function monsterPoolForDepth(d){
    const pool = [
      { glyph: ENT.GOBLIN, name: "Goblin", hp:[4,7], atk:[1,3], weight: 6 },
      { glyph: ENT.ORC,    name: "Orc",    hp:[7,12], atk:[2,5], weight: 4 }
    ];
    if(d >= 3)  pool.push({ glyph: ENT.SNAKE,  name:"Green Snake",           hp:[5,9],  atk:[2,4], weight: 4 });
    if(d >= 6)  pool.push({ glyph: ENT.CUBE,   name:"Blue Gelatinous Cube",  hp:[9,14], atk:[3,5], weight: 3 });
    if(d >= 9)  pool.push({ glyph: ENT.DRAGON, name:"Red Fire Dragon",       hp:[14,20],atk:[5,8], weight: 2 });
    if(d >= 12) pool.push({ glyph: ENT.CRAWLER,name:"Orange Carrion Crawler",hp:[12,18],atk:[4,7], weight: 3 });
    if(d >= 15) pool.push({ glyph: ENT.WALKER, name:"White Undead Walker",   hp:[16,24],atk:[5,8], weight: 3 });
    if(d >= 18) pool.push({ glyph: ENT.WRAITH, name:"Elder Ringwraith",      hp:[22,30],atk:[7,10],weight: 2 });
    return pool;
  }

  function pickWeighted(pool){
    const total = pool.reduce((s,p)=>s+p.weight,0);
    let r = Math.random()*total;
    for(const p of pool){
      r -= p.weight;
      if(r <= 0) return p;
    }
    return pool[pool.length-1];
  }

  function makeMonsterForDepth(d){
    const base = pickWeighted(monsterPoolForDepth(d));
    return {
      glyph: base.glyph,
      name: base.name,
      hp: randInt(base.hp[0], base.hp[1]),
      atk: randInt(base.atk[0], base.atk[1])
    };
  }

  function isAreaAllRock(tiles, x0,y0,w,h){
    for(let x=x0; x<x0+w; x++){
      for(let y=y0; y<y0+h; y++){
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) return false;
        if(tiles[x][y] !== TILE.ROCK) return false;
      }
    }
    return true;
  }

  function addSecretRooms(lvl, depth){
    const tiles = lvl.tiles;
    const secret = lvl.secret;
    const secretDoors = lvl.secretDoors;

    const secretCount = randInt(SECRET_ROOM_MIN, SECRET_ROOM_MAX);
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];

    let placed = 0;
    for(let attempts=0; attempts<2200 && placed<secretCount; attempts++){
      const ax = randInt(2, MAP_W-3);
      const ay = randInt(2, MAP_H-3);
      const at = tiles[ax][ay];
      if(!(at===TILE.FLOOR || at===TILE.CORR)) continue;
      if(secret[ax][ay]) continue;

      const dir = dirs[randInt(0, dirs.length-1)];
      const wx = ax + dir.dx;
      const wy = ay + dir.dy;
      if(wx<2||wy<2||wx>=MAP_W-2||wy>=MAP_H-2) continue;
      if(tiles[wx][wy] !== TILE.ROCK) continue;

      const len = randInt(2, 5);
      const rw = randInt(4, 8);
      const rh = randInt(4, 7);
      const endx = wx + dir.dx * len;
      const endy = wy + dir.dy * len;

      let rx, ry;
      if(dir.dx !== 0){
        rx = endx + (dir.dx > 0 ? 0 : -rw+1);
        ry = endy - Math.floor(rh/2);
      } else {
        rx = endx - Math.floor(rw/2);
        ry = endy + (dir.dy > 0 ? 0 : -rh+1);
      }

      let corridorOk = true;
      for(let i=1;i<=len;i++){
        const x = wx + dir.dx*i;
        const y = wy + dir.dy*i;
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) { corridorOk=false; break; }
        if(tiles[x][y] !== TILE.ROCK) { corridorOk=false; break; }
      }
      if(!corridorOk) continue;
      if(!isAreaAllRock(tiles, rx, ry, rw, rh)) continue;

      const wk = keyXY(wx,wy);
      if(secretDoors.has(wk)) continue;
      secretDoors.set(wk, { discovered:false });

      for(let i=1;i<=len;i++){
        const x = wx + dir.dx*i;
        const y = wy + dir.dy*i;
        tiles[x][y] = TILE.CORR;
        secret[x][y] = true;
      }
      carveRoom(tiles, {x:rx,y:ry,w:rw,h:rh}, secret);

      if(chance(SECRET_SHORTCUT_CHANCE) && depth < 20){
        const sx = randInt(rx+1, rx+rw-2);
        const sy = randInt(ry+1, ry+rh-2);
        tiles[sx][sy] = TILE.SDOWN;
      }

      placed++;
    }
  }

  // ---------- DOORS ----------
  function isPassableForDoorCandidate(t){ return (t === TILE.FLOOR || t === TILE.CORR); }
  function isWall(t){ return (t === TILE.ROCK); }
  function inBounds(x,y){ return x>=1 && y>=1 && x<MAP_W-1 && y<MAP_H-1; }
  function isExistingDoor(t){
    return (t === TILE.DOOR_C || t === TILE.DOOR_O || t === TILE.LDOOR_C || t === TILE.SD_C || t === TILE.SD_O);
  }

  function placeDoorsOnChokepoints(lvl){
    const tiles = lvl.tiles;
    const candidates = [];

    for(let x=2; x<MAP_W-2; x++){
      for(let y=2; y<MAP_H-2; y++){
        const t = tiles[x][y];
        if(!isPassableForDoorCandidate(t)) continue;
        if(t === TILE.DOWN || t === TILE.SDOWN) continue;
        if(lvl.secret[x][y]) continue;

        const n = tiles[x][y-1], s = tiles[x][y+1], w = tiles[x-1][y], e = tiles[x+1][y];

        const passN = isPassableForDoorCandidate(n) || n === TILE.DOWN || n === TILE.SDOWN;
        const passS = isPassableForDoorCandidate(s) || s === TILE.DOWN || s === TILE.SDOWN;
        const passW = isPassableForDoorCandidate(w) || w === TILE.DOWN || w === TILE.SDOWN;
        const passE = isPassableForDoorCandidate(e) || e === TILE.DOWN || e === TILE.SDOWN;

        const wallN = isWall(n);
        const wallS = isWall(s);
        const wallW = isWall(w);
        const wallE = isWall(e);

        const verticalChoke = passN && passS && wallW && wallE;
        const horizChoke    = passW && passE && wallN && wallS;

        if(!(verticalChoke || horizChoke)) continue;

        candidates.push({x,y});
      }
    }

    for(let i=candidates.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
    }

    const doors = [];
    for(const c of candidates){
      if(!chance(DOOR_CHANCE)) continue;

      let nearStairs = false;
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          const nx=c.x+dx, ny=c.y+dy;
          if(!inBounds(nx,ny)) continue;
          const tt = tiles[nx][ny];
          if(tt === TILE.DOWN || tt === TILE.SDOWN){ nearStairs = true; break; }
        }
        if(nearStairs) break;
      }
      if(nearStairs) continue;

      let adjDoor = false;
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          if(dx===0 && dy===0) continue;
          const nx=c.x+dx, ny=c.y+dy;
          if(!inBounds(nx,ny)) continue;
          if(isExistingDoor(tiles[nx][ny])) { adjDoor=true; break; }
        }
        if(adjDoor) break;
      }
      if(adjDoor) continue;

      tiles[c.x][c.y] = TILE.DOOR_C;
      doors.push({x:c.x, y:c.y});
    }

    return doors;
  }

  function lockDoorsNoAdjacency(tiles, doorCoords, startPos){
    const lockedSet = new Set();
    const isDoorTile = (t) => (t===TILE.DOOR_C || t===TILE.LDOOR_C || t===TILE.DOOR_O);

    for(const d of doorCoords){
      if(!chance(LOCKED_DOOR_CHANCE)) continue;
      const dist = Math.max(Math.abs(d.x-startPos.x), Math.abs(d.y-startPos.y));
      if(dist < 4) continue;
      tiles[d.x][d.y] = TILE.LDOOR_C;
      lockedSet.add(keyXY(d.x,d.y));
    }

    const q = Array.from(lockedSet).map(parseKey);
    const seen = new Set(lockedSet);

    while(q.length){
      const cur = q.pop();
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          if(dx===0 && dy===0) continue;
          const nx = cur.x + dx, ny = cur.y + dy;
          if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1) continue;
          const t = tiles[nx][ny];
          if(!isDoorTile(t)) continue;
          const nk = keyXY(nx,ny);
          if(seen.has(nk)) continue;

          tiles[nx][ny] = TILE.LDOOR_C;
          lockedSet.add(nk);
          seen.add(nk);
          q.push({x:nx,y:ny});
        }
      }
    }

    return Array.from(lockedSet).map(parseKey);
  }

  // ---------- Key chests placement ----------
  function findRoomContaining(lvl, pos){
    const tiles = lvl.tiles;
    const {x:cx,y:cy} = pos;
    if(tiles[cx][cy] !== TILE.FLOOR) return null;
    let x1=cx, x2=cx, y1=cy, y2=cy;
    while(x1>1 && tiles[x1-1][cy]===TILE.FLOOR) x1--;
    while(x2<MAP_W-2 && tiles[x2+1][cy]===TILE.FLOOR) x2++;
    while(y1>1 && tiles[cx][y1-1]===TILE.FLOOR) y1--;
    while(y2<MAP_H-2 && tiles[cx][y2+1]===TILE.FLOOR) y2++;
    return { x:x1, y:y1, w:(x2-x1+1), h:(y2-y1+1) };
  }

  function placeKeyChests(lvl, depth){
    const tiles = lvl.tiles;
    const neededKeys = lvl.lockedDoors.length;
    if(neededKeys <= 0) return;

    const keyChestCount =
      neededKeys <= 2 ? 1 :
      neededKeys <= 5 ? 2 : 3;

    let remaining = neededKeys;
    const keyCounts = [];
    for(let i=0;i<keyChestCount;i++){
      if(i === keyChestCount - 1){
        keyCounts.push(remaining);
      } else {
        const give = Math.max(1, Math.floor(remaining / (keyChestCount - i)));
        const jitter = Math.random() < 0.4 ? 0 : 1;
        const amt = Math.min(remaining - (keyChestCount - i - 1), give + jitter);
        keyCounts.push(amt);
        remaining -= amt;
      }
    }

    const startRoom = findRoomContaining(lvl, lvl.startPos);
    const isNormal = (x,y) => !lvl.secret[x][y];

    function canPlaceChestAt(x,y){
      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) return false;
      if(t === TILE.DOWN || t === TILE.SDOWN) return false;
      if(t === TILE.DOOR_C || t === TILE.DOOR_O || t === TILE.LDOOR_C) return false;
      if(!isNormal(x,y)) return false;

      if(startRoom && x>=startRoom.x && x<startRoom.x+startRoom.w && y>=startRoom.y && y<startRoom.y+startRoom.h){
        return false;
      }

      const k = keyXY(x,y);
      if(lvl.items.has(k) || lvl.traps.has(k) || lvl.monsters.has(k) || lvl.traders.has(k)) return false;
      return true;
    }

    for(const kc of keyCounts){
      let placed = false;

      for(let tries=0; tries<20000 && !placed; tries++){
        const x = randInt(2, MAP_W-3);
        const y = randInt(2, MAP_H-3);
        if(!canPlaceChestAt(x,y)) continue;

        const baseGold = randInt(6,16) + depth*2;
        lvl.items.set(keyXY(x,y), { type: ENT.CHEST, gold: baseGold, keys: kc });
        placed = true;
      }

      if(!placed){
        for(let tries=0; tries<20000 && !placed; tries++){
          const x = randInt(2, MAP_W-3);
          const y = randInt(2, MAP_H-3);
          if(!isNormal(x,y)) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          const k = keyXY(x,y);
          if(lvl.items.has(k) || lvl.traps.has(k) || lvl.monsters.has(k) || lvl.traders.has(k)) continue;
          const baseGold = randInt(6,16) + depth*2;
          lvl.items.set(k, { type: ENT.CHEST, gold: baseGold, keys: kc });
          placed = true;
        }
      }
    }

    // Optional: allow exactly one loose key sometimes in the start room (tutorial feel)
    // Comment out this entire block to enforce chest-only keys.
    if(startRoom && Math.random() < 0.20){
      for(let tries=0; tries<4000; tries++){
        const x = randInt(startRoom.x+1, startRoom.x+startRoom.w-2);
        const y = randInt(startRoom.y+1, startRoom.y+startRoom.h-2);
        const t = tiles[x][y];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        const k = keyXY(x,y);
        if(lvl.items.has(k) || lvl.traps.has(k) || lvl.monsters.has(k) || lvl.traders.has(k)) continue;
        lvl.items.set(k, { type: "__LOOSE_KEY__" }); // internal marker, rendered as k-less; picked up as 1 key
        break;
      }
    }
  }

  // ---------- Potion selection ----------
  function rollPotionType(depth){
    const d = Math.min(20, Math.max(1, depth));
    const k = d - 1; // 0..19

    // Base weights match the debug mix (36/16/16/14/13/5), then shift gently with depth
    const wHeal   = Math.max(18, 36 - Math.floor(k * 0.6));
    const wPoison = 16 + Math.floor(k * 0.05);
    const wInvis  = 16 + Math.floor(k * 0.05);
    const wTrans  = 14 + Math.floor(k * 0.20);
    const wInvinc = 13 + Math.floor(k * 0.20);
    const wTele   =  5 + Math.floor(k * 0.15);

    const items   = [POTION.HEAL, POTION.POISON, POTION.INVIS, POTION.TRANSMUTE, POTION.INVINC, POTION.TELE];
    const weights = [wHeal,       wPoison,       wInvis,       wTrans,          wInvinc,        wTele];

    return weightedChoice(items, weights);
  }

  
  // ---------- ENVIRONMENT (Step 3: room-only placement; render-only overlays) ----------
  const ENV_ROOM_CHANCE = 1.0; // chance a given eligible room becomes an env room (when a level theme is active) // per room
  const ENV_MAX_FRACTION = 0.42;
  const ENV_MIN_DEPTH = 2; // no environments on level 1
    const ENV_LEVEL_CHANCE = 0.60; // chance a level gets an environmental theme at all
    const ENV_ROOMS_MIN = 1;
    const ENV_ROOMS_MAX = 3; // fewer, more cohesive rooms per level
    const ENV_THEMES = [
      { name: 'water+slime', types: ['water','slime'], weights: [0.65, 0.35] },
      { name: 'fire+mist',  types: ['fire','mist'],   weights: [0.60, 0.40] }
    ];
  

  const ENV_GLYPH = {
    water: '‚âà',
    slime: '~',
    fire:  'x',
    mist:  '‚ñë'
  };
  const ENV_COLOR = {
    water: '#57c7ff',
    slime: '#6fcf6a',
    fire:  '#ff7043',
    mist:  '#b6c0c8'
  };

  function placeLevelEnvironments(lvl, rooms, depth, startPos){
  // Environments are purely visual overlays (passable). Keep them cohesive per level.

  // DEBUG: force environments in every room starting at level 1 for testing.
  // Cycles room-by-room through the available environment types so each room is different.
  if(DEBUG){
    if(!rooms || rooms.length === 0) return;
    const debugTypes = ['water','slime','fire','mist'];
    lvl.envTheme = 'debug';
    for(let i=0;i<rooms.length;i++){
      const r = rooms[i];
      if(!r) continue;
      const area = r.w * r.h;
      const cap = Math.floor(area * ENV_MAX_FRACTION);
      if(cap <= 0) continue;
      const target = Math.min(cap, Math.max(4, Math.floor(cap * 0.75))); // fairly full but always under cap
      const envType = debugTypes[i % debugTypes.length];

      // Seed position inside room interior
      let sx = randInt(r.x + 1, r.x + r.w - 2);
      let sy = randInt(r.y + 1, r.y + r.h - 2);

      const q = [[sx, sy]];
      const seen = new Set();
      let placed = 0;

      while(q.length && placed < target){
        const [x,y] = q.shift();
        const k = keyXY(x,y);
        if(seen.has(k)) continue;
        seen.add(k);

        if(x < r.x || x >= r.x + r.w || y < r.y || y >= r.y + r.h) continue;
        if(lvl.tiles[x][y] !== TILE.FLOOR) continue;
        if(lvl.env[x][y]) continue;

        lvl.env[x][y] = envType;
        placed++;

        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        shuffleInPlace(dirs);
        for(const [dx,dy] of dirs){
          const nx = x + dx, ny = y + dy;
          if(nx < r.x || nx >= r.x + r.w || ny < r.y || ny >= r.y + r.h) continue;
          const nk = keyXY(nx,ny);
          if(seen.has(nk)) continue;
          if(Math.random() < 0.85) q.push([nx,ny]);
        }
      }
    }
    return;
  }
  if(!rooms || rooms.length === 0) return;
  if(depth < ENV_MIN_DEPTH) return;
  if(Math.random() > ENV_LEVEL_CHANCE) return;

  const theme = choice(ENV_THEMES);
  lvl.envTheme = theme.name;

  const startRoom = findRoomContaining(lvl, startPos);

  // Eligible rooms: exclude the start room so the opening stays readable.
  const eligible = rooms.filter(r => {
    if(!r) return false;
    if(startRoom && r === startRoom) return false;
    // Also skip tiny rooms to avoid visual clutter.
    return (r.w * r.h) >= 30;
  });

  if(eligible.length === 0) return;

  // Pick a small number of rooms for cohesive patches.
  shuffleInPlace(eligible);
  const maxRooms = Math.min(ENV_ROOMS_MAX, eligible.length);
  const minRooms = Math.min(ENV_ROOMS_MIN, maxRooms);
  const roomCount = randInt(minRooms, maxRooms);
  const chosenRooms = eligible.slice(0, roomCount);

  for(const r of chosenRooms){
    if(Math.random() > ENV_ROOM_CHANCE) continue;

    const area = r.w * r.h;
    const cap = Math.floor(area * ENV_MAX_FRACTION);
    if(cap <= 0) continue;

    // Target fill: less random, more cohesive (closer to cap but still under it)
    const target = randInt(Math.max(4, Math.floor(cap * 0.45)), cap);

    const envType = weightedChoice(theme.types, theme.weights);

    // Seed position inside room interior
    let sx = randInt(r.x + 1, r.x + r.w - 2);
    let sy = randInt(r.y + 1, r.y + r.h - 2);

    // Grow a patch by BFS
    const q = [[sx, sy]];
    const seen = new Set();
    let placed = 0;

    while(q.length && placed < target){
      const [x,y] = q.shift();
      const k = keyXY(x,y);
      if(seen.has(k)) continue;
      seen.add(k);

      // Only overlay on floor inside this room
      if(x < r.x || x >= r.x + r.w || y < r.y || y >= r.y + r.h) continue;
      if(lvl.tiles[x][y] !== TILE.FLOOR) continue;

      // Don't overwrite existing environment
      if(lvl.env[x][y]) continue;

      lvl.env[x][y] = envType;
      placed++;

      // Push neighbors with slight bias (keeps it blobby)
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      shuffleInPlace(dirs);
      for(const [dx,dy] of dirs){
        const nx = x + dx, ny = y + dy;
        if(nx < r.x || nx >= r.x + r.w || ny < r.y || ny >= r.y + r.h) continue;
        const nk = keyXY(nx,ny);
        if(seen.has(nk)) continue;
        if(Math.random() < 0.85) q.push([nx,ny]);
      }
    }
  }
}

function generateLevel(depth){
    const tiles = makeGrid(MAP_W, MAP_H, TILE.ROCK);
    const seen = makeGrid(MAP_W, MAP_H, false);
    const visible = makeGrid(MAP_W, MAP_H, false);
    const env = makeGrid(MAP_W, MAP_H, 0);
    const secret = makeGrid(MAP_W, MAP_H, false);
    const secretDoors = new Map();

    const rooms = [];
    const roomTarget = randInt(ROOMS_MIN, ROOMS_MAX);

    for(let i=0;i<ROOM_ATTEMPTS && rooms.length<roomTarget;i++){
      const w = randInt(ROOM_W[0], ROOM_W[1]);
      const h = randInt(ROOM_H[0], ROOM_H[1]);
      const x = randInt(2, MAP_W - w - 3);
      const y = randInt(2, MAP_H - h - 3);
      const r = {x,y,w,h, cx: Math.floor(x+w/2), cy: Math.floor(y+h/2)};
      if(rooms.some(o => rectsOverlapInflated(r,o,2))) continue;
      carveRoom(tiles, r);
      rooms.push(r);
    }
    if(rooms.length < 5){
      const r = {x: 10, y: 6, w: 22, h: 10, cx: 21, cy: 11};
      carveRoom(tiles, r);
      rooms.push(r);
    }

    rooms.sort((a,b)=>a.cx-b.cx);
    for(let i=1;i<rooms.length;i++){
      const a=rooms[i-1], b=rooms[i];
      carveCorridor(tiles, a.cx,a.cy,b.cx,b.cy);
    }

    const startPos = findOpenSpot(tiles, rooms[0]);
    const downPos = findOpenSpot(tiles, rooms[rooms.length-1]);
    tiles[downPos.x][downPos.y] = TILE.DOWN;

    const items = new Map();
    const traps = new Map();
    const monsters = new Map();
    const traders = new Map();

    const lvl = {
      tiles, seen, visible, env, items, traps, monsters, traders,
      startPos, downPos, player: {...startPos},
      secret, secretDoors,
      lockedDoors: [],
      doorCoords: []
    };

    addSecretRooms(lvl, depth);

    lvl.doorCoords = placeDoorsOnChokepoints(lvl);
    lvl.lockedDoors = lockDoorsNoAdjacency(tiles, lvl.doorCoords, startPos);

    // Trader spawn
    if(chance(TRADER_SPAWN_CHANCE)){
      for(let tries=0; tries<8000; tries++){
        const x = randInt(2, MAP_W-3);
        const y = randInt(2, MAP_H-3);
        if(lvl.secret[x][y]) continue;
        const t = tiles[x][y];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        if((x===startPos.x && y===startPos.y) || (x===downPos.x && y===downPos.y)) continue;
        traders.set(keyXY(x,y), { name: "Trader" });
        break;
      }
    }
    const forbidOnTrader = (x,y) => traders.has(keyXY(x,y));

    const isNormal = (x,y) => !lvl.secret[x][y];
    const isSecret = (x,y) => lvl.secret[x][y];

    // Vitality Shrine (optional permanent HP growth)
    // DEBUG: force a shrine into the starting room for testing
    if(DEBUG && game.hpMax < MAX_HP_CAP){
      const startRoom = rooms.find(r =>
        startPos.x >= r.x && startPos.x < (r.x + r.w) &&
        startPos.y >= r.y && startPos.y < (r.y + r.h)
      );
      if(startRoom){
        let placed = false;
        for(let tries=0; tries<8000 && !placed; tries++){
          const x = randInt(startRoom.x + 1, startRoom.x + startRoom.w - 2);
          const y = randInt(startRoom.y + 1, startRoom.y + startRoom.h - 2);
          if(!isNormal(x,y)) continue;
          if(forbidOnTrader(x,y)) continue;
          if(x===startPos.x && y===startPos.y) continue;
          const k = keyXY(x,y);
          if(items.has(k)) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          if(t===TILE.DOWN || t===TILE.SDOWN) continue;
          if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) continue;
          items.set(k, { type: ENT.SHRINE });
          placed = true;
        }
      }
    } else if(Math.random() < VITALITY_SHRINE_CHANCE && game.hpMax < MAX_HP_CAP){
      // keep away from start for fairness
      const minDist = 6;
      scatter(items, tiles, 1, () => ({ type: ENT.SHRINE }),
        (x,y) => isNormal(x,y) && (Math.max(Math.abs(x-startPos.x), Math.abs(y-startPos.y)) >= minDist),
        forbidOnTrader
      );
    }


    // Torches
    const torchCount = TORCH_BASE_COUNT + Math.floor(depth / TORCH_BONUS_EVERY_LEVELS) * TORCH_PER_LEVEL_BONUS;
    scatter(items, tiles, torchCount, () => ({ type: ENT.TORCH }), isNormal, forbidOnTrader);

    // Base spawns (excluding most chests: key chests will add more)
    const potionCount = randInt(3,5) + Math.floor(depth/5);
    const chestCount  = randInt(1,2) + Math.floor(depth/9);
    const trapCount   = randInt(2,4) + Math.floor(depth/5);
    const monsterCount= randInt(3,6) + Math.floor(depth/3);

    scatter(items, tiles, potionCount, () => ({ type: ENT.POTION, potion: rollPotionType(depth) }), isNormal, forbidOnTrader);

    // Normal gold-only chests (key chests added later)
    scatter(items, tiles, chestCount,  () => ({ type: ENT.CHEST, gold: randInt(6,16) + depth*2, keys: 0 }), isNormal, forbidOnTrader);

    if(depth === 1){
      // Guaranteed starting weapon placed on level 1 (player begins unarmed)
      const r0 = rooms[0] || {x:2,y:2,w:10,h:6};
      let placed = false;
      for(let tries=0; tries<6000 && !placed; tries++){
        const x = randInt(r0.x+1, r0.x+r0.w-2);
        const y = randInt(r0.y+1, r0.y+r0.h-2);
        if(x===startPos.x && y===startPos.y) continue;
        if(lvl.secret[x][y]) continue;
        if(tiles[x][y] !== TILE.FLOOR) continue;
        const k = keyXY(x,y);
        if(items.has(k) || traps.has(k) || monsters.has(k) || traders.has(k)) continue;
        items.set(k, { type: ENT.WEAPON, atk: 3, name: "Dagger" });
        placed = true;
      }
      if(!placed){
        // Fallback: anywhere passable not on start
        for(let tries=0; tries<6000 && !placed; tries++){
          const x = randInt(2, MAP_W-3);
          const y = randInt(2, MAP_H-3);
          if(x===startPos.x && y===startPos.y) continue;
          if(lvl.secret[x][y]) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          const k = keyXY(x,y);
          if(items.has(k) || traps.has(k) || monsters.has(k) || traders.has(k)) continue;
          items.set(k, { type: ENT.WEAPON, atk: 3, name: "Dagger" });
          placed = true;
        }
      }
    } else if(Math.random() < 0.35){
      scatter(items, tiles, 1, () => ({ type: ENT.WEAPON, atk: weaponAtkForDepth(depth), name: weaponNameForDepth(depth) }), isNormal, forbidOnTrader);
    }

    scatter(traps, tiles, trapCount, () => ({ revealed:false, dmg: randInt(2,5)+Math.floor(depth/6) }), isNormal, forbidOnTrader);
    for(let i=0;i<monsterCount;i++){
      scatter(monsters, tiles, 1, () => makeMonsterForDepth(depth), isNormal, forbidOnTrader);
    }

    // Secret loot
    const secretPotions = Math.max(1, Math.floor(potionCount/2));
    const secretChests  = Math.max(1, Math.floor(chestCount/1.5));
    scatter(items, tiles, secretPotions, () => ({ type: ENT.POTION, potion: rollPotionType(depth) }), isSecret, forbidOnTrader);
    scatter(items, tiles, secretChests, () => ({ type: ENT.CHEST, gold: (randInt(6,16) + depth*2) * SECRET_REWARD_MULT, keys: 0 }), isSecret, forbidOnTrader);
    scatter(items, tiles, Math.max(1, Math.floor(torchCount/3)), () => ({ type: ENT.TORCH }), isSecret, forbidOnTrader);
    const secretTrapCount = Math.max(2, Math.floor(trapCount * SECRET_TRAP_MULT));
    scatter(traps, tiles, secretTrapCount, () => ({ revealed:false, dmg: randInt(2,5)+Math.floor(depth/6) + 1 }), isSecret, forbidOnTrader);

    // Place key chests AFTER doors exist (so it knows exact needed key count)
    placeKeyChests(lvl, depth);

    // Boss on 20
    if(depth === 20){
      for(let tries=0; tries<9000; tries++){
        const x = randInt(2, MAP_W-3);
        const y = randInt(2, MAP_H-3);
        if(!isNormal(x,y)) continue;
        const t = tiles[x][y];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        const k = keyXY(x,y);
        if(monsters.has(k) || traders.has(k)) continue;
        monsters.set(k, { glyph: ENT.HORROR, hp: 34, atk: 9, name: "Deep Horror" });
        break;
      }
    }

    
    // Step 3: populate room environments (render-only overlays)
    placeLevelEnvironments(lvl, rooms, depth, startPos);
return lvl;
  }

  // ---------- SECRET DOOR REVEAL ----------
  function tryRevealAdjacentSecretDoors(lvl){
    const px = lvl.player.x, py = lvl.player.y;
    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        if(dx===0 && dy===0) continue;
        const x = px + dx, y = py + dy;
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) continue;

        const k = keyXY(x,y);
        if(!lvl.secretDoors.has(k)) continue;
        const sd = lvl.secretDoors.get(k);
        if(sd.discovered) continue;
        if(lvl.tiles[x][y] !== TILE.ROCK) continue;

        if(chance(SECRET_REVEAL_CHANCE)){
          sd.discovered = true;
          lvl.tiles[x][y] = TILE.SD_C;
          logMsg("A secret door reveals itself!");
        }
      }
    }
  }

  // ---------- FOV / LOS ----------
  function isDoorClosed(t){ return (t === TILE.DOOR_C || t === TILE.SD_C || t === TILE.LDOOR_C); }
  function isBlockingTile(lvl, x, y){
    const t = lvl.tiles[x][y];
    return (t === TILE.ROCK) || isDoorClosed(t);
  }
  function hasLos(lvl, x0,y0,x1,y1){
    let dx = Math.abs(x1-x0), sx = x0<x1 ? 1 : -1;
    let dy = -Math.abs(y1-y0), sy = y0<y1 ? 1 : -1;
    let err = dx + dy;
    let x=x0, y=y0;
    while(true){
      if(x===x1 && y===y1) return true;
      if(!(x===x0 && y===y0) && isBlockingTile(lvl, x, y)) return false;
      const e2 = 2*err;
      if(e2 >= dy){ err += dy; x += sx; }
      if(e2 <= dx){ err += dx; y += sy; }
      if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false;
    }
  }
  function computeFov(lvl){
    const R = currentVisionRadius();
    for(let x=0;x<MAP_W;x++) for(let y=0;y<MAP_H;y++) lvl.visible[x][y]=false;
    const px = lvl.player.x, py = lvl.player.y;
    for(let dx=-R; dx<=R; dx++){
      for(let dy=-R; dy<=R; dy++){
        const x = px + dx, y = py + dy;
        if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
        if(dx*dx + dy*dy > R*R) continue;
        if(hasLos(lvl, px, py, x, y)){
          lvl.visible[x][y] = true;
          lvl.seen[x][y] = true;
        }
      }
    }
    for(const [k, tr] of lvl.traps.entries()){
      const {x,y} = parseKey(k);
      if(lvl.visible[x][y]) tr.revealed = true;
    }
  }

  // ---------- TRADER PROMPT DEFAULT N ----------
  function handlePromptOnMoveStart(prevPos){
    if(!game.prompt) return;
    const p = game.prompt;
    if(!prevPos) return;
    if(prevPos.x !== p.x || prevPos.y !== p.y) return;

    if(p.type === 'trade'){
      logMsg("Trade declined.");
      clearPrompt();
      return;
    }
    if(p.type === 'shrine'){
      // leaving without answering defaults to N
      resolveShrine(false);
      return;
    }
  }
  function openTraderPromptIfStanding(lvl){
    const p = lvl.player;
    const k = keyXY(p.x,p.y);
    if(!lvl.traders.has(k)) return;
    setPrompt({
      type: 'trade',
      x: p.x,
      y: p.y,
      costPotion: TRADER_POTION_COST,
      costWeapon: TRADER_WEAPON_COST,
      atkBonus: TRADER_WEAPON_ATK_BONUS,
      selection: 'A'
    });
    logMsg("A trader offers goods for gold.");
  }

  function resolveTrade(accepted){
    const lvl = getLevel(game.depth);
    const p = game.prompt;
    if(!p || p.type !== 'trade') return;

    const onTile = (lvl.player.x === p.x && lvl.player.y === p.y);
    if(!onTile){ clearPrompt(); return; }

    if(!accepted){
      logMsg("Trade declined.");
      clearPrompt();
      return;
    }

    const sel = p.selection || 'A';
    if(sel === 'A'){
      if(game.gold < p.costPotion){
        logMsg(`Not enough gold. Potion costs ${p.costPotion}g.`);
        clearPrompt();
        return;
      }
      if(game.inv.potions.length >= POTION_CAP){
        logMsg(`Potion satchel is full (cap ${POTION_CAP}).`);
        clearPrompt();
        return;
      }
      game.gold -= p.costPotion;
      const potion = chance(0.60) ? POTION.HEAL : rollPotionType(game.depth);
      game.inv.potions.push(potion);
      logMsg(`Bought a ${POTION_NAME[potion]} potion for ${p.costPotion}g.`);
      clearPrompt();
      return;
    }

    if(sel === 'B'){
      if(game.gold < p.costWeapon){
        logMsg(`Not enough gold. Weapon upgrade costs ${p.costWeapon}g.`);
        clearPrompt();
        return;
      }
      game.gold -= p.costWeapon;
      game.atk += TRADER_WEAPON_ATK_BONUS;
      game.weaponName = `${game.weaponName}+`;
      logMsg(`Upgraded weapon! ATK +${TRADER_WEAPON_ATK_BONUS} for ${p.costWeapon}g.`);
      clearPrompt();
      return;
    }

    clearPrompt();
  }

  function resolveShrine(accepted){
    const lvl = getLevel(game.depth);
    const p = game.prompt;
    if(!p || p.type !== 'shrine') return;

    // shrine is single-use; remove it whenever resolved
    const k = keyXY(p.x, p.y);
    lvl.items.delete(k);

    if(!accepted){
      logMsg("Shrine vanishes.");
      clearPrompt();
      return;
    }

    if(game.hpMax >= MAX_HP_CAP){
      logMsg("The shrine is dormant. You feel no further growth is possible.");
      logMsg("Shrine vanishes.");
      clearPrompt();
      return;
    }

    // Determine payment: potion preferred, otherwise gold
    let paidMsg = "";
    if(game.inv.potions.length > 0){
      const idx = randInt(0, game.inv.potions.length - 1);
      const lost = game.inv.potions.splice(idx, 1)[0];
      paidMsg = `(lost a ${POTION_NAME[lost]} potion)`;
    } else {
      const cost = SHRINE_BASE_GOLD_COST + game.depth * SHRINE_GOLD_PER_LEVEL;
      if(game.gold < cost){
        logMsg("You have nothing to offer the shrine.");
        logMsg("Shrine vanishes.");
        clearPrompt();
        return;
      }
      game.gold -= cost;
      paidMsg = `(paid ${cost} gold)`;
    }

    game.hpMax += 1;
    game.hp = Math.min(game.hpMax, game.hp + 1);

    logMsg(`Vitality surges through you. +1 Max HP ${paidMsg}.`);
    logMsg("Shrine vanishes.");
    clearPrompt();
  }

  // ---------- MOVEMENT / COMBAT ----------
  function tilePassable(lvl, x, y){
    const t = lvl.tiles[x][y];
    if(t === TILE.ROCK) return false;
    if(t === TILE.DOOR_C || t === TILE.SD_C) return false;
    if(t === TILE.LDOOR_C){
      if(hasTransmute()) return true;
      return false;
    }
    return true;
  }

  function playerAttack(lvl, mx, my){
    playSfx('attack');
    const k = keyXY(mx,my);
    const m = lvl.monsters.get(k);
    let dmg = randInt(1, game.atk);
    if(!game.weaponEquipped){
      dmg = Math.max(1, Math.floor(dmg/2));
    }
    m.hp -= dmg;
    logMsg(`Hit ${m.name} for ${dmg}.`);
    if(m.hp <= 0){
      lvl.monsters.delete(k);
      const bounty = randInt(1,4) + Math.floor(game.depth/4);
      game.gold += bounty;
      logMsg(`${m.name} falls. +${bounty} gold.`);
    }
  }

  function monstersAct(lvl){
    const p = lvl.player;
    const next = new Map(lvl.monsters);

    for(const [k, m] of lvl.monsters.entries()){
      const {x,y} = parseKey(k);
      const dist = Math.max(Math.abs(p.x-x), Math.abs(p.y-y));

      if(dist === 1){
        const dmg = randInt(1, m.atk);
        if(hasInvincible()){
          logMsg(`${m.name} strikes ‚Äî but it cannot harm you.`);
        } else {
          game.hp -= dmg;
          playSfx('damage');
          logMsg(`${m.name} hits for ${dmg}.`);
          if(game.hp <= 0){
            game.hp = 0;
            lvl.monsters = next;
            endGameLose();
            return;
          }
        }
        continue;
      }

      const inSight = lvl.visible[x]?.[y] === true;
      const canChase = (!hasInvis());

      let dx=0, dy=0;

      if(inSight && canChase && dist <= 8 && Math.random() < 0.65){
        dx = clamp(p.x - x, -1, 1);
        dy = clamp(p.y - y, -1, 1);
      } else if(Math.random() < 0.35){
        dx = randInt(-1,1);
        dy = randInt(-1,1);
      } else {
        continue;
      }

      const nx = x + dx, ny = y + dy;
      const nk = keyXY(nx,ny);
      if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1) continue;
      if(nx===p.x && ny===p.y) continue;
      if(next.has(nk)) continue;
      if(!tilePassable(lvl, nx, ny)) continue;

      // Slime slows monster movement (half speed)
      const curE = envAt(lvl, x, y);
      const nextE = envAt(lvl, nx, ny);
      const inSlime = (curE === 'slime' || nextE === 'slime');
      if(inSlime){
        if(!m._slimeWait){
          m._slimeWait = true;
          next.set(k, m); // stay put this turn
          continue;
        } else {
          m._slimeWait = false;
        }
      } else {
        m._slimeWait = false;
      }

      next.delete(k);
      next.set(nk, m);
    }

    lvl.monsters = next;
  }

  function openDoorIfPresent(lvl, x, y){
    const t = lvl.tiles[x][y];

    if(t === TILE.DOOR_C){
      lvl.tiles[x][y] = TILE.DOOR_O;
      logMsg("Opened a door.");
      return true;
    }

    if(t === TILE.LDOOR_C){
      if(hasTransmute()){
        logMsg("You phase through the locked door.");
        return false;
      }

      if(game.inv.keys <= 0){
        if(LOCKED_DOOR_BREAKS_WITHOUT_KEY){
          lvl.tiles[x][y] = TILE.LDOOR_O;
          if(hasInvincible()){
            logMsg("No key ‚Äî forced the lock. It shatters harmlessly.");
          } else if(LOCK_BREAK_DAMAGE > 0){
            game.hp -= LOCK_BREAK_DAMAGE;
            logMsg(`No key ‚Äî forced the lock. Door breaks open! (-${LOCK_BREAK_DAMAGE} HP)`);
            if(game.hp <= 0){
              game.hp = 0;
              endGameLose();
              return true;
            }
          } else {
            logMsg("No key ‚Äî forced the lock. Door breaks open!");
          }
        } else {
          logMsg("Locked. A key is needed.");
        }
        return true;
      }

      game.inv.keys--;
      lvl.tiles[x][y] = TILE.LDOOR_O;
      logMsg("Unlocked and opened the door.");
      return true;
    }

    if(t === TILE.SD_C){
      lvl.tiles[x][y] = TILE.SD_O;
      logMsg("Opened a secret door.");
      return true;
    }

    return false;
  }

  const DIRS = {
    'w':[0,-1], 'a':[-1,0], 's':[0,1], 'd':[1,0],
    'q':[-1,-1], 'e':[1,-1], 'z':[-1,1], 'c':[1,1],
    '.':[0,0]
  };

  function tryMove(dx, dy){
    if(game.ended) return;

    const lvl = getLevel(game.depth);
    const p = lvl.player;
    const prev = {x:p.x, y:p.y};

    handlePromptOnMoveStart(prev);

    if(dx===0 && dy===0){
      playSfx('wait');
      monstersAct(lvl);

      // Rest heal: +0.25 HP per wait turn, capped at 3 HP healed per level
      const REST_CAP = 3;
      game.restHealedThisLevel = game.restHealedThisLevel || 0;

      if(game.hp < game.hpMax && game.restHealedThisLevel < REST_CAP){
        game.restFrac = (game.restFrac || 0) + 0.25;

        // Only allow healing up to remaining cap
        const remaining = REST_CAP - game.restHealedThisLevel;
        const gainRaw = Math.floor(game.restFrac);
        const gain = Math.min(remaining, gainRaw);

        if(gain > 0){
          game.hp = Math.min(game.hpMax, game.hp + gain);
          game.restHealedThisLevel += gain;
          game.restFrac = game.restFrac - gain;
          logMsg("Resting, you healed for 1HP");
        }

        if(game.restHealedThisLevel >= REST_CAP){
          game.restFrac = 0;
          if(!game.restCapMsgShown){
            logMsg("You feel no further benefit from resting here.");
            game.restCapMsgShown = true;
          }
        }
      } else {
        // No benefit (either full HP or cap reached)
        game.restFrac = 0;
        if(game.restHealedThisLevel >= REST_CAP && !game.restCapMsgShown){
          logMsg("You feel no further benefit from resting here.");
          game.restCapMsgShown = true;
        }
      }

      computeFov(lvl);
      renderAll();
      return;
    }

    const nx = p.x + dx, ny = p.y + dy;
    if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H){ playSfx('bump'); return; }

    if(dx!==0 && dy!==0){
      const ok1 = tilePassable(lvl, p.x+dx, p.y);
      const ok2 = tilePassable(lvl, p.x, p.y+dy);
      if(!ok1 && !ok2){ playSfx('bump'); return; }
    }

    const mk = keyXY(nx,ny);

    if(lvl.monsters.has(mk)){
      musicMaybeTrigger('monsterEncounter');
      playerAttack(lvl, nx, ny);
      monstersAct(lvl);
      computeFov(lvl);
      renderAll();
      return;
    }

    const doorT = lvl.tiles[nx][ny];
    const isDoorTile = (doorT === TILE.DOOR_C || doorT === TILE.SD_C || doorT === TILE.LDOOR_C);
    if(isDoorTile){
      const consumed = openDoorIfPresent(lvl, nx, ny);
      if(consumed){
        monstersAct(lvl);
        computeFov(lvl);
        renderAll();
        return;
      }
    }

    if(!tilePassable(lvl, nx, ny)){ playSfx('bump'); return; }

    // Slime slows movement: first keypress consumes a step without moving.
    const curEnv = envAt(lvl, p.x, p.y);
    const nextEnv = envAt(lvl, nx, ny);
    const inSlimeMove = (curEnv === 'slime' || nextEnv === 'slime');
    if(inSlimeMove){
      if(!game.slimeWait){
        game.slimeWait = true;
        logMsg("Slime slows your passage.");
        advanceTorchOnMove();
        tickEffectsOnStep();
        if(game.ended) { renderAll(true); return; }
        monstersAct(lvl);
        computeFov(lvl);
        renderAll();
        return;
      } else {
        game.slimeWait = false;
      }
    } else {
      game.slimeWait = false;
    }

    p.x = nx; p.y = ny;

    playSfx('step');

    // Roaming ambience (situational, probabilistic)
    musicMaybeTrigger('roam');

    applyEnvironmentOnEnter(lvl, prev.x, prev.y, p.x, p.y);
    if(game.ended) { renderAll(true); return; }

    advanceTorchOnMove();
    tickEffectsOnStep();
    if(game.ended) { renderAll(true); return; }

    tryRevealAdjacentSecretDoors(lvl);

    // Traps
    if(lvl.traps.has(mk)){
      const tr = lvl.traps.get(mk);
      tr.revealed = true;

      if(hasInvincible()){
        logMsg("A trap triggers ‚Äî but you are invincible.");
      } else if(hasTransmute()){
        logMsg("You float over the trap unharmed.");
      } else {
        game.hp -= tr.dmg;
        playSfx('damage');
        logMsg(`A trap springs! Took ${tr.dmg} damage.`);
        if(game.hp <= 0){
          game.hp = 0;
          endGameLose();
          return;
        }
      }
    }

    // Items
    if(lvl.items.has(mk)){
      const it = lvl.items.get(mk);

      if(it.type === ENT.POTION){
        if(game.inv.potions.length >= POTION_CAP){
          logMsg(`Potion satchel full (cap ${POTION_CAP}). Left potion behind.`);
        } else {
          game.inv.potions.push(it.potion || POTION.HEAL);
          playSfx('pickup');
          logMsg(`Picked up a ${POTION_NAME[it.potion || POTION.HEAL]} potion (!).`);
          lvl.items.delete(mk);
        }
      } else if(it.type === ENT.CHEST){
        const gold = it.gold || 0;
        game.gold += gold;

        const foundKeys = it.keys || 0;
        if(foundKeys > 0){
          const space = KEY_CAP - game.inv.keys;
          const take = Math.max(0, Math.min(space, foundKeys));
          game.inv.keys += take;

          if(take === foundKeys){
            logMsg(`Opened a chest: +${gold} gold and +${take} keys.`);
          } else {
            const left = foundKeys - take;
            logMsg(`Opened a chest: +${gold} gold and +${take} keys (key ring full; ${left} left behind).`);
          }
        } else {
          logMsg(`Found treasure ($): +${gold} gold.`);
        }
        playSfx('pickup');
        lvl.items.delete(mk);
      } else if(it.type === ENT.WEAPON){
        game.atk = Math.max(game.atk, it.atk);
        game.weaponName = it.name;
        playSfx('pickup');
        game.weaponEquipped = true;
        logMsg(`Weapon found (∆™): ${it.name} (ATK ${it.atk}).`);
        lvl.items.delete(mk);
      } else if(it.type === ENT.TORCH){
        const cnt = it.count || 1;
        const space = TORCH_CAP - game.inv.torches;
        const take = Math.max(0, Math.min(space, cnt));

        if(take <= 0){
          logMsg(`Torch pack full (cap ${TORCH_CAP}). Left torch behind.`);
        } else {
          game.inv.torches += take;
          logMsg(take === 1 ? "Picked up a torch (t)." : `Picked up ${take} torches (t).`);

          if(take >= cnt){
            lvl.items.delete(mk);
          } else {
            it.count = cnt - take;
            lvl.items.set(mk, it);
          }

          if(!game.torch.lit && game.torch.radius === VISION_DARK){
            maybeAutoLightTorch();
          }
        }
      } else if(it.type === ENT.SHRINE){
        // Vitality Shrine prompt
        setPrompt({ type: 'shrine', x: p.x, y: p.y });
        logMsg("The shrine pulses with life. Gain +1 vitality at a cost? (Y/N)");
        renderAll();
        return;
      } else if(it.type === "__LOOSE_KEY__"){
        if(game.inv.keys >= KEY_CAP){
          logMsg(`Key ring full (cap ${KEY_CAP}). Left key behind.`);
        } else {
          game.inv.keys++;
          playSfx('pickup');
          logMsg("Picked up a key.");
          lvl.items.delete(mk);
        }
      }
    }

    openTraderPromptIfStanding(lvl);

    monstersAct(lvl);
    computeFov(lvl);
    renderAll();
  }

  function tryDescend(){
    if(game.ended) return;

    const lvl = getLevel(game.depth);
    const {x,y} = lvl.player;
    const t = lvl.tiles[x][y];

    if(!(t === TILE.DOWN || t === TILE.SDOWN)){
      logMsg("No stairs here.");
      renderAll();
      return;
    }

    if(game.depth === 20){
      endGameWin();
      return;
    }

    const nextDepth = game.depth + 1;
    loadLevel(nextDepth);
    playSfx('descend');
    playSfx('descend');

    // Music: descending interlude
    musicMaybeTrigger('descend', true);

    logMsg(t === TILE.SDOWN
      ? `Secret shortcut! Dropped to level ${String(nextDepth).padStart(2,'0')}.`
      : `Descended to level ${String(nextDepth).padStart(2,'0')}.`
    );

    const heal = randInt(1,3);
    game.hp = Math.min(game.hpMax, game.hp + heal);
    renderAll();
  }

  function drinkHealingPotion(){
    if(game.ended) return;

    // Prevent wasting healing when already at full HP.
    if(game.hp >= game.hpMax){
      logMsg("HP is already full.");
      renderAll();
      return;
    }

    if(!consumePotionByType(POTION.HEAL)){
      logMsg("No healing potions.");
      renderAll();
      return;
    }

    playSfx('drink');

    const heal = randInt(POTION_HEAL_RANGE[0], POTION_HEAL_RANGE[1]);
    game.hp = Math.min(game.hpMax, game.hp + heal);
    logMsg(`Drank Healing (purple). +${heal} HP.`);
    renderAll();
  }

  function drinkPotionType(type){
    if(game.ended) return;

    if(!consumePotionByType(type)){
      logMsg(`No ${POTION_NAME[type]} potions.`);
      renderAll();
      return;
    }

    playSfx('drink');

    if(type === POTION.POISON){
      game.effects.poison = Math.max(game.effects.poison, POISON_STEPS);
      logMsg(`Drank Poison (green). ${POISON_STEPS} steps of sickness!`);
      renderAll();
      return;
    }

    if(type === POTION.INVIS){
      game.effects.invis = Math.max(game.effects.invis, INVIS_STEPS);
      logMsg(`Drank Invisibility (grey). Monsters lose your scent (${INVIS_STEPS}).`);
      renderAll();
      return;
    }

    if(type === POTION.TRANSMUTE){
      game.effects.transmute = Math.max(game.effects.transmute, TRANSMUTE_STEPS);
      logMsg(`Drank Transmutation (ochre). You float & phase (${TRANSMUTE_STEPS}).`);
      renderAll();
      return;
    }

    if(type === POTION.INVINC){
      game.effects.invincible = Math.max(game.effects.invincible, INVINCIBLE_STEPS);
      logMsg(`Drank Invincibility (red). Nothing can harm you (${INVINCIBLE_STEPS}).`);
      renderAll();
      return;
    }

    if (type === POTION.TELE) {
        const lvl = getLevel(game.depth);
        const pos = findRandomOpenTile(lvl);

        lvl.player.x = pos.x;
        lvl.player.y = pos.y;

        logMsg(`Your body tingles as you are transported to an unknown location.`);

        computeFov(lvl);
        renderAll();
        return;
    }

    logMsg("Drank a strange potion‚Ä¶ nothing happens.");
    renderAll();
  }

  
  // ---------- RENDERING ----------
  function spanChar(ch, color, dim=false){
    const safe = ch === ' ' ? '&nbsp;' : escapeHtml(ch);
    const cls = dim ? ' class="dim"' : '';
    return `<span style="color:${color}"${cls}>${safe}</span>`;
  }

  function baseColorFor(lvl, x, y, glyph){
    if(glyph === '+' || glyph === '‚Äì' || glyph === '|') return COL.wall;
    const t = lvl.tiles[x][y];
    if(t === TILE.FLOOR) return COL.floor;
    if(t === TILE.CORR) return COL.corr;
    if(t === TILE.DOOR_C || t === TILE.DOOR_O) return COL.door;
    if(t === TILE.LDOOR_C) return COL.locked;
    if(t === TILE.SD_C || t === TILE.SD_O) return COL.sdoor;
    if(t === TILE.DOWN) return COL.stairs;
    if(t === TILE.SDOWN) return COL.shortcut;
    return COL.rock;
  }

  function colorForEntity(it){
    if(it.type === ENT.CHEST) return COL.chest;
    if(it.type === ENT.WEAPON) return COL.weapon;
    if(it.type === ENT.TORCH) return COL.torch;
    if(it.type === ENT.SHRINE) return COL.shrine;
    if(it.type === ENT.POTION) return POTION_COLOR[it.potion || POTION.HEAL] || COL.potion_purple;
    return COL.fg;
  }

  function isPassableTerrainForWalls(lvl, x, y){
    if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false;
    const t = lvl.tiles[x][y];
    return (
      t === TILE.FLOOR || t === TILE.CORR ||
      t === TILE.DOOR_C || t === TILE.DOOR_O ||
      t === TILE.LDOOR_C || t === TILE.LDOOR_O ||
      t === TILE.SD_C || t === TILE.SD_O ||
      t === TILE.DOWN || t === TILE.SDOWN
    );
  }

  function drawWallGlyph(lvl, x, y){
    const t = lvl.tiles[x][y];
    if(t !== TILE.ROCK) return null;

    const passN = isPassableTerrainForWalls(lvl, x, y-1);
    const passS = isPassableTerrainForWalls(lvl, x, y+1);
    const passW = isPassableTerrainForWalls(lvl, x-1, y);
    const passE = isPassableTerrainForWalls(lvl, x+1, y);

    const anyAdj = passN || passS || passW || passE;
    if(!anyAdj) return ' ';

    const vert = (passW || passE);
    const horiz = (passN || passS);

    if(vert && horiz) return '+';
    if(vert) return '|';
    if(horiz) return '‚Äì';
    return ' ';
  }

  function torchHudText(){
    if(!game) return "";
const r = currentVisionRadius();
    if(!game.torch.lit) return `Dark (${r})`;
    if(game.torch.burnLeft > 0) return `Burn ${r} ¬∑ ${game.torch.burnLeft}`;
    const stepsLeft = Math.max(0, (r - VISION_DARK));
    return `Dim ${r} ¬∑ ${stepsLeft}`;
  }

  function renderHud(freeze=false){
    const lvl = getLevel(game.depth);
    const depthStr = `${String(game.depth).padStart(2,'0')}/${String(game.maxDepth).padStart(2,'0')}`;
    const potionByType = countPotionsByType();
    const potionCount = game.inv.potions.length;

    const potBits = [];
    if(potionByType[POTION.HEAL] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.HEAL]};"><b>H</b>${potionByType[POTION.HEAL]}</span>`);
    if(potionByType[POTION.POISON] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.POISON]};"><b>P</b>${potionByType[POTION.POISON]}</span>`);
    if(potionByType[POTION.INVIS] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.INVIS]};"><b>I</b>${potionByType[POTION.INVIS]}</span>`);
    if(potionByType[POTION.TRANSMUTE] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.TRANSMUTE]};"><b>X</b>${potionByType[POTION.TRANSMUTE]}</span>`);
    if(potionByType[POTION.INVINC] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.INVINC]};"><b>V</b>${potionByType[POTION.INVINC]}</span>`);
    if(potionByType[POTION.TELE] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.TELE]};"><b>E</b>${potionByType[POTION.TELE]}</span>`);

    // Drink mapping in this build:
    // P = Heal, 0=Poison, 1=Invis, 2=Trans, 3=Invinc, 4=Tele
    const potPills = [
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.POISON]};color:${POTION_COLOR[POTION.POISON]};"><b>0</b> Poison</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.INVIS]};color:${POTION_COLOR[POTION.INVIS]};"><b>1</b> Invis</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.TRANSMUTE]};color:${POTION_COLOR[POTION.TRANSMUTE]};"><b>2</b> Trans</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.INVINC]};color:${POTION_COLOR[POTION.INVINC]};"><b>3</b> Invinc</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.TELE]};color:${POTION_COLOR[POTION.TELE]};"><b>4</b> Tele</span>`
    ];

    const effects = [];
    if(game.effects.poison > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.POISON]};color:${POTION_COLOR[POTION.POISON]};">POISON ${game.effects.poison}</span>`);
    if(game.effects.invis > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.INVIS]};color:${POTION_COLOR[POTION.INVIS]};">INVIS ${game.effects.invis}</span>`);
    if(game.effects.transmute > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.TRANSMUTE]};color:${POTION_COLOR[POTION.TRANSMUTE]};">TRANS ${game.effects.transmute}</span>`);
    if(game.effects.invincible > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.INVINC]};color:${POTION_COLOR[POTION.INVINC]};">INVINC ${game.effects.invincible}</span>`);

    $hud.innerHTML = `
      <span class="hud-item title hud-logo">
        <img src="dd_logo.jpg" alt="Dungeons Deep" />
      </span>
      <span class="hud-item muted">Lvl <b>${depthStr}</b></span>
      <span class="hud-item muted">HP <b>${game.hp}</b>/<b>${game.hpMax}</b></span>
      <span class="hud-item muted">ATK <b>${game.atk}</b> (${escapeHtml(game.weaponName)})</span>
      <span class="hud-item muted">GOLD <b>${game.gold}</b></span>
      <span class="hud-item muted">KEYS <b>${game.inv.keys}</b>/<b>${KEY_CAP}</b></span>
      <span class="hud-item muted">TORCH <b>${game.inv.torches}</b>/<b>${TORCH_CAP}</b> ¬∑ VISION <b>${torchHudText()}</b></span>
      <span class="hud-item muted">POTS <b>${potionCount}</b>/<b>${POTION_CAP}</b>${potBits.length ? ` ¬∑ ${potBits.join(' ')}` : ``}</span>
      <span class="hud-item muted">DRINK <b>P</b> Heal ¬∑ ${potPills.join(' ')}</span>
      ${effects.length ? `<span class="hud-item muted">EFFECTS <span class="effects">${effects.join('')}</span></span>` : ``}
    
      ${DEBUG ? `
        <div class="hud-debug">
          <span><b>DEBUG</b></span>
          <span>Depth: ${game.depth}</span>
          <span>HP: ${game.hp}/${game.hpMax}</span>
          <span>Potions: ${game.inv.potions.length}/${POTION_CAP}</span>
          <span>Keys: ${game.inv.keys}/${KEY_CAP}</span>
          <span>Torches: ${game.inv.torches}/${TORCH_CAP}</span>
          <span>Fx: P${game.effects.poison} I${game.effects.invis} T${game.effects.transmute} V${game.effects.invincible}</span>
        </div>
      ` : ``}
`;
  }

  function renderScreenAscii(){
    const lvl = getLevel(game.depth);
    computeFov(lvl);

    const px = lvl.player.x, py = lvl.player.y;
    const vx0 = clamp(px - Math.floor(VIEW_W/2), 0, MAP_W - VIEW_W);
    const vy0 = clamp(py - Math.floor(VIEW_H/2), 0, MAP_H - VIEW_H);

    let out = "";
    for(let y=vy0; y<vy0+VIEW_H; y++){
      for(let x=vx0; x<vx0+VIEW_W; x++){
        const seen = lvl.seen[x][y];
        const vis = lvl.visible[x][y];

        if(!seen){
          out += spanChar(' ', COL.rock, false);
          continue;
        }

        let glyph = null;
        const t = lvl.tiles[x][y];

        if(
          t === TILE.DOOR_C || t === TILE.DOOR_O ||
          t === TILE.LDOOR_C || t === TILE.LDOOR_O ||
          t === TILE.SD_C || t === TILE.SD_O ||
          t === TILE.DOWN || t === TILE.SDOWN
        ){
          glyph = t;
        } else if(t === TILE.FLOOR){
          glyph = TILE.FLOOR;
        } else if(t === TILE.CORR){
          glyph = TILE.CORR;
        } else {
          glyph = drawWallGlyph(lvl, x, y);
        }

        let color = baseColorFor(lvl, x, y, glyph);
        const k = keyXY(x,y);

        // Environment overlay (render-only; passable). Applied only on visible floor/corridor.
        // NOTE: lvl.env stores an environment TYPE string ("water"/"slime"/"fire"/"mist"), not a glyph.
        if(vis && lvl.env){
          const et = lvl.env[x][y];
          if(et && (t === TILE.FLOOR || t === TILE.CORR)){
            glyph = ENV_GLYPH[et] || glyph;
            color = ENV_COLOR[et] || color;
          }
        }

        if(vis){
          if(lvl.items.has(k)){
            const it = lvl.items.get(k);
            glyph = (it.type === ENT.POTION) ? ENT.POTION :
                    (it.type === "__LOOSE_KEY__") ? 'k' :
                    it.type;
            color = (it.type === "__LOOSE_KEY__") ? COL.door : colorForEntity(it);
          }
          if(lvl.traps.has(k)){
            const tr = lvl.traps.get(k);
            if(tr.revealed){
              glyph = ENT.TRAP;
              color = COL.trap;
            }
          }
          if(lvl.monsters.has(k)){
            const m = lvl.monsters.get(k);
            glyph = m.glyph;
            color = MONSTER_COLOR[m.glyph] || COL.monster;
          }
          if(lvl.traders.has(k)){
            glyph = ENT.TRADER;
            color = COL.trader;
          }
          if(x===lvl.player.x && y===lvl.player.y){
            glyph = ENT.PLAYER;
            color = COL.player;
          }
        } else {
          color = COL.dim;
          if(lvl.traps.has(k) && lvl.traps.get(k).revealed){
            glyph = ENT.TRAP;
          }
        }

        out += spanChar(glyph, color, (!vis && seen));
      }
      out += "\n";
    }

    $screenAscii.innerHTML = out;
  }

  
  // ---------- RENDER MODE (ASCII ‚Üî TILES) ----------
  RENDER_MODE = "tiles"; // default to tiles so you can see it immediately

  // Embedded placeholder tileset (2 rows x 8 cols, 48px per tile). Replace later with your real art.
  TILE_PX = 48;
  const TILESET_SRC = "data:image/png;base64,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";
  const tilesetImg = new Image();
  tilesetImg.src = TILESET_SRC;

  // Ensure canvas matches the viewport grid.
  function sizeCanvas(){
    $screenCanvas.width = VIEW_W * TILE_PX;
    $screenCanvas.height = VIEW_H * TILE_PX;
  }

  const ctx = $screenCanvas.getContext("2d");

  const SPRITES = {
    // terrain
    [TILE.FLOOR]:  { x:0, y:0 },
    [TILE.CORR]:   { x:0, y:0 }, // same as floor for placeholder
    "+":           { x:1, y:0 }, // wall placeholder
    [TILE.DOOR_C]: { x:2, y:0 },
    [TILE.DOOR_O]: { x:3, y:0 },
    [TILE.LDOOR_C]:{ x:2, y:0 },
    [TILE.LDOOR_O]:{ x:3, y:0 },
    [TILE.SD_C]:   { x:2, y:0 },
    [TILE.SD_O]:   { x:3, y:0 },
    [TILE.DOWN]:   { x:4, y:0 },
    [TILE.SDOWN]:  { x:4, y:0 },
    "~":           { x:5, y:0 }, // water overlay
    "t":           { x:6, y:0 }, // torch overlay
    " ":           { x:7, y:0 }, // void

    // entities / items
    [ENT.PLAYER]:  { x:0, y:1 },
    [ENT.ORC]:     { x:1, y:1 },
    [ENT.SLIME]:   { x:2, y:1 },
    [ENT.POTION]:  { x:3, y:1 },
    [ENT.GOLD]:    { x:4, y:1 },
    [ENT.CHEST]:   { x:5, y:1 },
    "k":           { x:6, y:1 }, // loose key placeholder
    [ENT.TRAP]:    { x:7, y:1 },
    [ENT.TRADER]:  { x:1, y:1 }, // temp reuse (orc)
  };

  function drawSprite(glyph, cellX, cellY, alpha=1){
    const s = SPRITES[glyph] || SPRITES[TILE.FLOOR];
    const sx = s.x * TILE_PX, sy = s.y * TILE_PX;
    const dx = cellX * TILE_PX, dy = cellY * TILE_PX;
    ctx.globalAlpha = alpha;
    ctx.drawImage(tilesetImg, sx, sy, TILE_PX, TILE_PX, dx, dy, TILE_PX, TILE_PX);
    ctx.globalAlpha = 1;
  }

  function renderScreenTiles(){
    const lvl = getLevel(game.depth);
    computeFov(lvl);

    const px = lvl.player.x, py = lvl.player.y;
    const vx0 = clamp(px - Math.floor(VIEW_W/2), 0, MAP_W - VIEW_W);
    const vy0 = clamp(py - Math.floor(VIEW_H/2), 0, MAP_H - VIEW_H);

    ctx.clearRect(0,0,$screenCanvas.width,$screenCanvas.height);

    for(let y=vy0; y<vy0+VIEW_H; y++){
      for(let x=vx0; x<vx0+VIEW_W; x++){
        const seen = lvl.seen[x][y];
        const vis  = lvl.visible[x][y];

        const cx = x - vx0;
        const cy = y - vy0;

        if(!seen){
          drawSprite(" ", cx, cy, 1);
          continue;
        }

        const t = lvl.tiles[x][y];
        let glyph;

        if(
          t === TILE.DOOR_C || t === TILE.DOOR_O ||
          t === TILE.LDOOR_C || t === TILE.LDOOR_O ||
          t === TILE.SD_C || t === TILE.SD_O ||
          t === TILE.DOWN || t === TILE.SDOWN
        ){
          glyph = t;
        } else if(t === TILE.FLOOR){
          glyph = TILE.FLOOR;
        } else if(t === TILE.CORR){
          glyph = TILE.CORR;
        } else {
          glyph = "+";
        }

        const alphaBase = vis ? 1 : 0.32;

        // Base
        drawSprite(glyph, cx, cy, alphaBase);

        // Environment overlay (placeholder support)
        if(vis && lvl.env){
          const et = lvl.env[x][y];
          if(et && (t === TILE.FLOOR || t === TILE.CORR)){
            if(et === "water") drawSprite("~", cx, cy, 1);
          }
        }

        const k = keyXY(x,y);

        if(vis){
          if(lvl.items.has(k)){
            const it = lvl.items.get(k);
            let ig = it.type;
            if(it.type === "__LOOSE_KEY__") ig = "k";
            drawSprite(ig, cx, cy, 1);
          }
          if(lvl.traps.has(k)){
            const tr = lvl.traps.get(k);
            if(tr.revealed) drawSprite(ENT.TRAP, cx, cy, 1);
          }
          if(lvl.monsters.has(k)){
            const m = lvl.monsters.get(k);
            drawSprite(m.glyph, cx, cy, 1);
          }
          if(lvl.traders.has(k)){
            drawSprite(ENT.TRADER, cx, cy, 1);
          }
          if(x===lvl.player.x && y===lvl.player.y){
            drawSprite(ENT.PLAYER, cx, cy, 1);
          }
        }
      }
    }
  }

  function setRenderMode(mode){
    RENDER_MODE = mode;
    if(mode === "tiles"){
      $screenAscii.style.display = "none";
      $screenCanvas.style.display = "block";
      sizeCanvas();
    } else {
      $screenCanvas.style.display = "none";
      $screenAscii.style.display = "block";
    }
    renderAll();
  }

  // Wrapper used by renderAll()
  function renderScreen(){
    if(RENDER_MODE === "ascii") return renderScreenAscii();
    return renderScreenTiles();
  }

function renderAll(freeze=false){
    renderHud(freeze);
    renderScreen();
    renderPrompt();

    // HUD end-state indicator via Reset button (no extra HUD clutter)
    if(game.ended){
      if(game.victory){
        $restartBtn.classList.add('btn-win');
        $restartBtn.classList.remove('btn-lose');
        $restartBtn.textContent = 'Reset (Victory)';
      }else{
        $restartBtn.classList.add('btn-lose');
        $restartBtn.classList.remove('btn-win');
        $restartBtn.textContent = 'Reset (Defeat)';
      }
    }else{
      $restartBtn.classList.remove('btn-win','btn-lose');
      $restartBtn.textContent = 'Reset';
    }
  }

  // ---------- INPUT ----------
  function handleKey(e){
    let k = e.key.toLowerCase();
    // Arrow keys support
    if(k === 'arrowup') k = 'w';
    else if(k === 'arrowdown') k = 's';
    else if(k === 'arrowleft') k = 'a';
    else if(k === 'arrowright') k = 'd';


    if(game.prompt && game.prompt.type === 'trade'){
      const p = game.prompt;
      if(k === 'a' || k === 'b'){
        p.selection = (k === 'a') ? 'A' : 'B';
        logMsg(`Selected ${(p.selection==='A') ? 'Potion' : 'Weapon upgrade'}.`);
        renderAll();
        return;
      }
    }

    if(game.prompt && game.prompt.type === 'shrine'){
      if(k === 'y'){ e.preventDefault(); resolveShrine(true); renderAll(); return; }
      if(k === 'n'){ e.preventDefault(); resolveShrine(false); renderAll(); return; }
    }

    if(game.prompt && game.prompt.type === 'trade'){
if(k === 'y'){
        e.preventDefault();
        resolveTrade(true);
        renderAll();
        return;
      }
      if(k === 'n'){
        e.preventDefault();
        resolveTrade(false);
        renderAll();
        return;
      }
 
    }

    if(game.ended) return;

    if(k === '>'){ e.preventDefault(); tryDescend(); return; }
    if(k === 'p'){ e.preventDefault(); drinkHealingPotion(); return; }
    if(k === '0'){ e.preventDefault(); drinkPotionType(POTION.POISON); return; }
    if(k === '1'){ e.preventDefault(); drinkPotionType(POTION.INVIS); return; }
    if(k === '2'){ e.preventDefault(); drinkPotionType(POTION.TRANSMUTE); return; }
    if(k === '3'){ e.preventDefault(); drinkPotionType(POTION.INVINC); return; }
    if(k === '4'){ e.preventDefault(); drinkPotionType(POTION.TELE); return; }
    // Wait / Rest (turn passes without movement)
    if(k === ' '){
      e.preventDefault();
      tryMove(0,0);
      return;
    }

    if(!(k in DIRS)) return;

    e.preventDefault();
    const [dx,dy] = DIRS[k];
    tryMove(dx,dy);
  }

  document.addEventListener('keydown', handleKey);
  $restartBtn.addEventListener('click', newGame);

  // ---------- START ----------
  renderLegend();
  newGame();
  setRenderMode(RENDER_MODE);
})();
</script>
</body>
</html>
